{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SmoothPoll","text":"<p>Project link GitHub.</p>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form/","title":"Poll Form","text":"<p>Poll form class used to display to the user the poll creation form.</p>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form/#apps.polls_management.classes.poll_form_utils.poll_form.PollForm","title":"<code>PollForm</code>","text":"<p>         Bases: <code>ModelForm</code></p> <p>Tool to create a new Poll</p> Source code in <code>apps/polls_management/classes/poll_form_utils/poll_form.py</code> <pre><code>class PollForm(ModelForm):\n\"\"\"Tool to create a new Poll\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if self.data.get(POLL_TYPE) is None:\n            self.data[POLL_TYPE] = PollModel.PollType.SINGLE_OPTION\n\n        # Make votable_mj true by default\n        self.fields[VOTABLE_MJ].initial = True\n\n        # if not already there, generate a short ID\n        self.fields[SHORT_ID].initial = ShortIdUtil.generate()\n        if self.data.get(SHORT_ID) is None:\n            self.data[SHORT_ID] = ShortIdUtil.generate()\n\n        # Randomize options by default\n        self.fields[RANDOMIZE_OPTIONS].initial = True\n\n        # Protection \n        if self.data.get(PROTECTION) is None:\n            self.data[PROTECTION] = PollModel.PollVoteProtection.UNPROTECTED\n        self.fields[PROTECTION].initial = PollModel.PollVoteProtection.UNPROTECTED\n\n        # Results visibility\n        if self.data.get(RESULTS_VISIBILITY) is None:\n            self.data[RESULTS_VISIBILITY] = PollModel.PollResultsVisibility.ALWAYS_VISIBLE\n        self.fields[RESULTS_VISIBILITY].initial = PollModel.PollResultsVisibility.ALWAYS_VISIBLE\n\n\n    class Meta:\n        model = PollModel\n\n        fields = [  NAME,\n                    QUESTION, \n                    POLL_TYPE,\n                    OPEN_DATETIME, \n                    CLOSE_DATETIME, \n                    PREDEFINITED, \n                    VOTABLE_MJ, \n                    PRIVATE, \n                    SHORT_ID, \n                    RANDOMIZE_OPTIONS,\n                    PROTECTION, \n                    RESULTS_VISIBILITY, \n                ]\n\n        labels = {\n                    NAME: _(\"Nome\"), \n                    QUESTION: _(\"Quesito\"), \n                    POLL_TYPE: _(\"Tipologia\"), \n                    OPEN_DATETIME: _(\"Data Apertura\"), \n                    CLOSE_DATETIME: _(\"Data Chiusura\"),\n                    AUTHOR: _(\"Nome dell'autore\"), \n                    VOTABLE_MJ: _(\"Rendi giudicabile anche con il Giudizio Maggioritario\"),\n                    PRIVATE: _(\"Scelta accessibile solo tramite link\"), \n                    SHORT_ID: _(\"Codice identificativo\"),\n                    RANDOMIZE_OPTIONS: _(\"Durante la fase di scelta o giudizio le opzioni saranno presentate in ordine casuale\"),\n                    PROTECTION: _(\"Tipo di protezione della scelta\"), \n                    RESULTS_VISIBILITY: _(\"Visibilit\u00e0 dei risultati\"),\n                }\n\n        help_texts = {\n                        NAME: _(\"Un nome sintetico che descrive la scelta\"), \n                        QUESTION: _(\"Quesito che verr\u00e0 posto a chi compie la scelta\"), \n                        POLL_TYPE: _(\"Il metodo che verr\u00e0 usato per esprimere la scelta e calcolare i risultati. &lt;a href=\\\"/info/\\\"  target='_blank'&gt;Scopri di pi\u00f9 sui diversi metodi di scelta&lt;/a&gt;.\"), \n                        OPEN_DATETIME: _(\"La data dalla quale sar\u00e0 possibile esprimere la scelta\"), \n                        CLOSE_DATETIME: _(\"La data dalla quale non sar\u00e0 pi\u00f9 possibile esprimere la scelta\"), \n                        AUTHOR: _(\"Il nome dell'autore che ha creato la scelta\"),\n                        VOTABLE_MJ: _(\"(abilita questa opzione se vuoi che una scelta sia giudicabile anche con il Giudizio Maggioritario)\"),\n                        PRIVATE: _(\"(se abiliti questa opzione la scelta non sar\u00e0 visibile nella sezione con tutte le scelte)\"),\n                        SHORT_ID: _(\"Codice identificativo univoco per il link\"), \n                        PROTECTION: _(\"Come evitare che la scelta venga effetuata pi\u00f9 volte dallo stesso utente\"), \n                        RESULTS_VISIBILITY: _(\"Quando possono essere visualizzati i risultati della scelta\"),\n                    }\n\n        error_messages = {\n            NAME: {\n                'max_length': _(\"Il nome inserito \u00e8 troppo lungo, cerca di essere pi\u00f9 sintetico\"),\n                'required': _(\"Dai un nome alla tua scelta\"), \n            },\n            QUESTION: {\n                'max_length': _(\"Il quesito inserito \u00e8 troppo lungo, cerca di essere pi\u00f9 sintetico\"),\n                'required': _(\"Inserisci la domanda da chiedere\"), \n            },\n            POLL_TYPE: {\n                'required': _(\"Seleziona una tipologia di scelta\"), \n            },\n            CLOSE_DATETIME: {\n                'required': _(\"Inserisci una data di chiusura per la scelta\"), \n            }, \n        }\n        widgets = {\n            OPEN_DATETIME: DateTimeInput(\n                format=('%Y-%m-%d %H:%M'), \n                attrs={\n                    'class':'form-control', \n                    'placeholder':'Scegli la data di apertura della scelta', \n                    'type':'datetime-local'\n                }\n            ),\n            CLOSE_DATETIME: DateTimeInput(\n                format=('%Y-%m-%d %H:%M'), \n                attrs={\n                    'class':'form-control', \n                    'placeholder':'Scegli la data di chiusura della scelta', \n                    'type':'datetime-local',\n                    # 'required':True\n                }\n            ),\n            PREDEFINITED: HiddenInput(),\n        }\n\n    def get_min_options(self) -&gt; int: \n\"\"\"Get poll min options (according to poll_type)\"\"\"\n        return 2\n\n    def get_type_verbose_name(self) -&gt; str:\n\"\"\"Get verbose name of current poll_type \n        (the one you may display on UI)\"\"\"\n\n        return PollModel(\n            name = self.data[NAME], \n            question = self.data[QUESTION], \n            poll_type = self.data[POLL_TYPE],\n            ).get_type_verbose_name()\n\n    def clean(self):\n\"\"\"Checks for errors related to date setting in the form\"\"\"\n\n        # checks on open and close datetime\n        open_datetime = self.cleaned_data.get(OPEN_DATETIME, None)\n        close_datetime = self.cleaned_data.get(CLOSE_DATETIME, None)\n\n        if open_datetime is not None and close_datetime is None:\n            self._errors[CLOSE_DATETIME] = self.error_class([\n                    'Inserisci anche una data di chisura'])\n        elif open_datetime is None and close_datetime is not None:\n            self._errors[OPEN_DATETIME] = self.error_class([\n                    'Inserisci anche una data di apertura'])\n        elif open_datetime is not None and close_datetime is not None:\n            if open_datetime &gt; close_datetime:\n                self._errors[CLOSE_DATETIME] = self.error_class([\n                    'Inserisci una data di chiusura successiva a quella di apertura'])\n\n        # checks on short id (used in URL)\n        short_id = ShortIdUtil(self.cleaned_data.get(SHORT_ID, \"\"), poll=self.instance)\n\n        if not short_id.validate_length():\n            self._errors[SHORT_ID] = self.error_class(['Il codice deve avere tra i 6 e i 60 caratteri'])\n        elif not short_id.validate_characters():\n            self._errors[SHORT_ID] = self.error_class(['Il codice deve essere formato solo da lettere e numeri'])\n        elif not short_id.validate_uniqness():\n            self._errors[SHORT_ID] = self.error_class(['Codice gi\u00e0 in uso, prova un altro'])\n\n        return self.cleaned_data\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form/#apps.polls_management.classes.poll_form_utils.poll_form.PollForm.clean","title":"<code>clean()</code>","text":"<p>Checks for errors related to date setting in the form</p> Source code in <code>apps/polls_management/classes/poll_form_utils/poll_form.py</code> <pre><code>def clean(self):\n\"\"\"Checks for errors related to date setting in the form\"\"\"\n\n    # checks on open and close datetime\n    open_datetime = self.cleaned_data.get(OPEN_DATETIME, None)\n    close_datetime = self.cleaned_data.get(CLOSE_DATETIME, None)\n\n    if open_datetime is not None and close_datetime is None:\n        self._errors[CLOSE_DATETIME] = self.error_class([\n                'Inserisci anche una data di chisura'])\n    elif open_datetime is None and close_datetime is not None:\n        self._errors[OPEN_DATETIME] = self.error_class([\n                'Inserisci anche una data di apertura'])\n    elif open_datetime is not None and close_datetime is not None:\n        if open_datetime &gt; close_datetime:\n            self._errors[CLOSE_DATETIME] = self.error_class([\n                'Inserisci una data di chiusura successiva a quella di apertura'])\n\n    # checks on short id (used in URL)\n    short_id = ShortIdUtil(self.cleaned_data.get(SHORT_ID, \"\"), poll=self.instance)\n\n    if not short_id.validate_length():\n        self._errors[SHORT_ID] = self.error_class(['Il codice deve avere tra i 6 e i 60 caratteri'])\n    elif not short_id.validate_characters():\n        self._errors[SHORT_ID] = self.error_class(['Il codice deve essere formato solo da lettere e numeri'])\n    elif not short_id.validate_uniqness():\n        self._errors[SHORT_ID] = self.error_class(['Codice gi\u00e0 in uso, prova un altro'])\n\n    return self.cleaned_data\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form/#apps.polls_management.classes.poll_form_utils.poll_form.PollForm.get_min_options","title":"<code>get_min_options()</code>","text":"<p>Get poll min options (according to poll_type)</p> Source code in <code>apps/polls_management/classes/poll_form_utils/poll_form.py</code> <pre><code>def get_min_options(self) -&gt; int: \n\"\"\"Get poll min options (according to poll_type)\"\"\"\n    return 2\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form/#apps.polls_management.classes.poll_form_utils.poll_form.PollForm.get_type_verbose_name","title":"<code>get_type_verbose_name()</code>","text":"<p>Get verbose name of current poll_type  (the one you may display on UI)</p> Source code in <code>apps/polls_management/classes/poll_form_utils/poll_form.py</code> <pre><code>def get_type_verbose_name(self) -&gt; str:\n\"\"\"Get verbose name of current poll_type \n    (the one you may display on UI)\"\"\"\n\n    return PollModel(\n        name = self.data[NAME], \n        question = self.data[QUESTION], \n        poll_type = self.data[POLL_TYPE],\n        ).get_type_verbose_name()\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form_session/","title":"Poll Form Session","text":"<p>Session util methods used during poll form creation process.</p>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form_session/#apps.polls_management.classes.poll_form_utils.poll_form_session.clean_session","title":"<code>clean_session(request)</code>","text":"<p>Clean current session from form data</p> Source code in <code>apps/polls_management/classes/poll_form_utils/poll_form_session.py</code> <pre><code>def clean_session(request: HttpRequest) -&gt; None: \n\"\"\"Clean current session from form data\"\"\"\n\n    # iterate all keys used to store form data\n    # to delete each of them\n    for key in _ALL_SESSION_KEYS:\n        if request.session.get(key) is not None:\n            del request.session[key]\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form_session/#apps.polls_management.classes.poll_form_utils.poll_form_session.get_poll_form","title":"<code>get_poll_form(request)</code>","text":"<p>Factory method to get current form  from session (or from POST request).</p> Source code in <code>apps/polls_management/classes/poll_form_utils/poll_form_session.py</code> <pre><code>def get_poll_form(request: HttpRequest) -&gt; PollForm:\n\"\"\"Factory method to get current form \n    from session (or from POST request).\"\"\"\n\n    # temp, TODO: fix in a seriuous way\n    try:\n        formdata = request.session.get(SESSION_FORMDATA)\n\n        if formdata is not None:\n            if isinstance(formdata, QueryDict):\n                formdata = formdata.dict()\n            # various book flags may be undefined \n            # --&gt; perform the check and adjust\n            for key in [VOTABLE_MJ, PRIVATE, RANDOMIZE_OPTIONS]:\n                if formdata.get(key) == \"undefined\" :\n                    formdata[key] = False\n            # save again in session\n            request.session[SESSION_FORMDATA] = PollForm(formdata).data\n    except:\n        print(\":)\")\n\n\n    # build a form for creation (w most updated data)\n    if request.session.get(SESSION_POLL_ID) is None:\n\n        return PollForm(request.POST or request.session.get(SESSION_FORMDATA) or None)\n\n    # build a form for editing an existing instance\n    try:\n        return PollForm(\n            # fill form data w current most updated\n            request.POST or request.session.get(SESSION_FORMDATA) or None, \n\n            # connect form to existing instance\n            instance= PollService.get_poll_by_id(\n                request.session.get(SESSION_POLL_ID))\n        )\n    except PollDoesNotExistException:\n        raise Http404(f\"Poll with id {request.session.get(SESSION_POLL_ID)} not found.\")\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/poll_form_session/#apps.polls_management.classes.poll_form_utils.poll_form_session.init_session_for_edit","title":"<code>init_session_for_edit(request, poll, override_data={}, error_message=None)</code>","text":"<p>Init session for edit. Run this method to prepare the  session for using the form to edit a poll.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>Request object.</p> required <code>poll</code> <code>PollModel</code> <p>The poll you wanna edit.</p> required <code>override_data</code> <code>dict</code> <p>Use this dict to override some params.</p> <code>{}</code> <code>error_message</code> <code>str</code> <p>Use this field to show user an initial error message.</p> <code>None</code> Source code in <code>apps/polls_management/classes/poll_form_utils/poll_form_session.py</code> <pre><code>def init_session_for_edit(request: HttpRequest, poll: PollModel, \n                          override_data: dict = {}, \n                          error_message: str = None) -&gt; None:\n\"\"\"Init session for edit. Run this method to prepare the \n    session for using the form to edit a poll.\n\n    Args:\n        request (HttpRequest): Request object.\n        poll (PollModel): The poll you wanna edit.\n        override_data (dict): Use this dict to override some params.\n        error_message (str): Use this field to show user an initial error message.    \n    \"\"\"\n\n    # init form with poll instance that should be modified \n    form = PollForm({\n        NAME: override_data.get(NAME, poll.name), \n        QUESTION: override_data.get(QUESTION, poll.question), \n        POLL_TYPE: override_data.get(POLL_TYPE, poll.poll_type), \n        OPEN_DATETIME: override_data.get(OPEN_DATETIME, poll.open_datetime),\n        CLOSE_DATETIME: override_data.get(CLOSE_DATETIME, poll.close_datetime),  \n        AUTHOR: override_data.get(AUTHOR, poll.author),\n        VOTABLE_MJ: override_data.get(VOTABLE_MJ, poll.votable_mj),\n        PRIVATE: override_data.get(PRIVATE, poll.private), \n        SHORT_ID: override_data.get(SHORT_ID, poll.short_id), \n        RANDOMIZE_OPTIONS: override_data.get(RANDOMIZE_OPTIONS, poll.randomize_options),\n        PROTECTION: override_data.get(PROTECTION, poll.protection), \n        RESULTS_VISIBILITY: override_data.get(RESULTS_VISIBILITY, poll.results_visibility), \n    }, instance=poll)\n\n    # init poll options with current ones\n    options: dict = {}\n    i: int = 1\n    for o in poll.options():\n        options[str(i)] = o.value\n        i += 1\n\n    # save everythingh in session, so form can be \n    # rendered with current data\n    request.session[SESSION_FORMDATA] = form.data\n    request.session[SESSION_POLL_ID] = poll.id\n    request.session[SESSION_OPTIONS] = options\n    request.session[SESSION_IS_EDIT] = True\n\n    # write in session eventual error message\n    if not error_message is None:\n        request.session[SESSION_ERROR] = error_message\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/short_id_util/","title":"Shor ID Util","text":"<p>Class used to generate and validate a short id url for a poll.</p>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/short_id_util/#apps.polls_management.classes.poll_form_utils.short_id_util.ShortIdUtil","title":"<code>ShortIdUtil</code>","text":"Source code in <code>apps/polls_management/classes/poll_form_utils/short_id_util.py</code> <pre><code>class ShortIdUtil:\n\n    @staticmethod\n    def generate() -&gt; str:\n\"\"\"Generate a short id for a poll that is unique in the db\n            Returns:\n                str: Unique short id.\n        \"\"\"\n        short_ids: List[str] = list(PollModel.objects.values_list('short_id', flat=True))\n        new_id: str = ''.join(random.choice(string.ascii_lowercase) for i in range(6))\n\n        limit: int = 100\n        while new_id in short_ids and limit &gt; 0:\n            new_id = ''.join(random.choice(string.ascii_lowercase) for i in range(6))\n            limit -= 1\n\n        if limit == 0:\n            raise Exception(\"Error generating short id\")\n\n        return new_id\n\n    @staticmethod\n    def validate(short_id: str) -&gt; bool:\n\"\"\"Validate the short id.\n\n        Args:\n            short_id (str): Short id to validate.\n\n        Returns:\n            bool: True if the short id is valid, False otherwise.\n        \"\"\"\n        short_ids: List[str] = list(PollModel.objects.values_list('short_id', flat=True))\n        if len(short_id) == 6 and short_id not in short_ids:\n            return True\n        else:\n            return False\n\n    def __init__(self, code: str, poll: PollModel=None) -&gt; None:\n        self.code: str = code or \"\"\n        self.poll: PollModel = poll\n\n    def validate_length(self) -&gt; bool:\n        return len(self.code) &gt;= 6 and len(self.code) &lt;= 60\n\n    def validate_characters(self) -&gt; bool:\n        return self.code.isalnum()\n\n    def validate_uniqness(self) -&gt; bool:\n\n        query = PollModel.objects.filter(short_id=self.code)\n\n        # if I am working on an already existent poll is acceptable\n        # this code is already used for this poll\n        if not self.poll is None:\n            query = query.filter(~Q(id__in=[self.poll.id]))\n\n        return query.count() == 0\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/short_id_util/#apps.polls_management.classes.poll_form_utils.short_id_util.ShortIdUtil.generate","title":"<code>generate()</code>  <code>staticmethod</code>","text":"<p>Generate a short id for a poll that is unique in the db</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique short id.</p> Source code in <code>apps/polls_management/classes/poll_form_utils/short_id_util.py</code> <pre><code>@staticmethod\ndef generate() -&gt; str:\n\"\"\"Generate a short id for a poll that is unique in the db\n        Returns:\n            str: Unique short id.\n    \"\"\"\n    short_ids: List[str] = list(PollModel.objects.values_list('short_id', flat=True))\n    new_id: str = ''.join(random.choice(string.ascii_lowercase) for i in range(6))\n\n    limit: int = 100\n    while new_id in short_ids and limit &gt; 0:\n        new_id = ''.join(random.choice(string.ascii_lowercase) for i in range(6))\n        limit -= 1\n\n    if limit == 0:\n        raise Exception(\"Error generating short id\")\n\n    return new_id\n</code></pre>"},{"location":"code_documentation/polls_management/classes/poll_form_utils/short_id_util/#apps.polls_management.classes.poll_form_utils.short_id_util.ShortIdUtil.validate","title":"<code>validate(short_id)</code>  <code>staticmethod</code>","text":"<p>Validate the short id.</p> <p>Parameters:</p> Name Type Description Default <code>short_id</code> <code>str</code> <p>Short id to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the short id is valid, False otherwise.</p> Source code in <code>apps/polls_management/classes/poll_form_utils/short_id_util.py</code> <pre><code>@staticmethod\ndef validate(short_id: str) -&gt; bool:\n\"\"\"Validate the short id.\n\n    Args:\n        short_id (str): Short id to validate.\n\n    Returns:\n        bool: True if the short id is valid, False otherwise.\n    \"\"\"\n    short_ids: List[str] = list(PollModel.objects.values_list('short_id', flat=True))\n    if len(short_id) == 6 and short_id not in short_ids:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"code_documentation/polls_management/classes/schulze_algorithm/schulze/","title":"Schulze algorithm","text":"<p>Schule algorithm used to obtain the results for schulze method polls.</p> <p>Ranks candidates by the Schulze method.</p> <p>For more information read http://en.wikipedia.org/wiki/Schulze_method.</p>"},{"location":"code_documentation/polls_management/classes/schulze_algorithm/schulze/#apps.polls_management.classes.schulze_algorithm.schulze.compute_ranks","title":"<code>compute_ranks(candidate_names, weighted_ranking_orders)</code>","text":"<p>Returns the Schulze ranking of candidates.</p> <p>See http://en.wikipedia.org/wiki/Schulze_method for details.</p> <p>Parameter candidate_names is a list which contains all the candidate names.</p> <p>Parameter weighted_ranking_orders is a list of pairs (ranking_order, weight), where: - ranking_order is a list of lists, which allows ties, e.g. [[a, b], [c], [d, e]] represents a = b &gt; c &gt; d = e. - weight is a numerical value, typically the number of voters who choose this ranking_order.</p> Source code in <code>apps/polls_management/classes/schulze_algorithm/schulze.py</code> <pre><code>def compute_ranks(candidate_names, weighted_ranking_orders):\n\"\"\"Returns the Schulze ranking of candidates.\n\n    See http://en.wikipedia.org/wiki/Schulze_method for details.\n\n    Parameter candidate_names is a list which contains all the candidate names.\n\n    Parameter weighted_ranking_orders is a list of pairs (ranking_order, weight), where:\n    - ranking_order is a list of lists, which allows ties, e.g. [[a, b], [c], [d, e]] represents a = b &gt; c &gt; d = e.\n    - weight is a numerical value, typically the number of voters who choose this ranking_order.\n    \"\"\"\n    d = _compute_d(weighted_ranking_orders)\n    p = _compute_p(d, candidate_names)\n    return _rank_p(candidate_names, p)\n</code></pre>"},{"location":"code_documentation/polls_management/classes/schulze_algorithm/schulze/#apps.polls_management.classes.schulze_algorithm.schulze.compute_schulze_ranking","title":"<code>compute_schulze_ranking(candidate_names, ballots)</code>","text":"<p>Returns the Schulze ranking of candidates, in the case where each ballot is given equal weight.</p> <p>Parameter candidate_names is a list which contains all the candidate names.</p> <p>Parameter ballots is a list of ballots, where each ballot is actually a ranking order expressed as a list of lists, e.g. [[a, b], [c], [d, e]] represents a = b &gt; c &gt; d = e.</p> Source code in <code>apps/polls_management/classes/schulze_algorithm/schulze.py</code> <pre><code>def compute_schulze_ranking(candidate_names, ballots):\n\"\"\"Returns the Schulze ranking of candidates, in the case where each ballot is given equal weight.\n\n    Parameter candidate_names is a list which contains all the candidate names.\n\n    Parameter ballots is a list of ballots, where each ballot is actually a ranking order expressed as a list of lists,\n    e.g. [[a, b], [c], [d, e]] represents a = b &gt; c &gt; d = e.\n    \"\"\"\n    weighted_ranking_orders = [(ballot, 1) for ballot in ballots]\n    return compute_ranks(candidate_names, weighted_ranking_orders)\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_create_service/","title":"Poll create service","text":"<p>Services related to poll creation.</p>"},{"location":"code_documentation/polls_management/services/poll_create_service/#apps.polls_management.services.poll_create_service.PollCreateService","title":"<code>PollCreateService</code>","text":"<p>Services related to CRUD operation on Polls</p> Source code in <code>apps/polls_management/services/poll_create_service.py</code> <pre><code>class PollCreateService:\n\"\"\"\n    Services related to CRUD operation on Polls \n    \"\"\"\n\n    @staticmethod\n    def create_or_edit_poll(poll_form: PollForm, options: List[str], user) -&gt; PollModel:\n\"\"\"Create a new poll starting from a PollForm object (or\n        apply the edits on the existing object)\n\n        Args:\n            poll_form: form containing data of object you wanna create.\n            options: list of all options (as strings). \n                They must be at least 2 and at most 10.\n\n        Raises:\n            MissingNameOrQuestionExcetion: your form has not all required data.\n            TooFewOptionsExcetion: you put in too few options for this type of poll.\n            TooManyOptionsExcetion: you put in too many options for this type of poll.\n\n        Returns:\n            poll: the initialized and saved PollModel object\n        \"\"\"\n        # validate form\n        if not poll_form.is_valid():\n            raise PollMainDataNotValidException(f\"Some data of passed poll_form is not valid. See errors:\\n{poll_form.errors}\")\n\n        # validate options\n        valid_options = list()\n        for o in options:\n            if o.strip() != \"\":\n                valid_options.append(o)\n\n        # ensuring is passed at least a certain number of options\n        if len(valid_options) &lt; poll_form.get_min_options():\n            raise TooFewOptionsException(f\"{poll_form.data.get('poll_type')} poll \" +\n                f\"(votable_mj={poll_form.data.get('votable_mj')}) needs at least \" +\n                f\"{poll_form.get_min_options()} options, {len(valid_options)} has given\")\n\n        # all polls can have at most 10 options\n        if len(valid_options) &gt; 10:\n            raise TooManyOptionsException(f\"A poll accepts at most 10 options, {len(valid_options)} has given\")\n\n        # create poll object from form\n        poll = poll_form.save(commit=False)\n        poll.author = user\n        poll.save()\n\n\n        # check if there are already options in the poll object\n        # and delete them (edit case)\n        if poll.options():\n            for previous_option in poll.options():\n                previous_option.delete()\n\n        # create option objects\n        for o_str in valid_options:\n            option = PollOptionModel(value=o_str)\n            option.poll_fk = poll\n            option.save()\n\n        return poll\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_create_service/#apps.polls_management.services.poll_create_service.PollCreateService.create_or_edit_poll","title":"<code>create_or_edit_poll(poll_form, options, user)</code>  <code>staticmethod</code>","text":"<p>Create a new poll starting from a PollForm object (or apply the edits on the existing object)</p> <p>Parameters:</p> Name Type Description Default <code>poll_form</code> <code>PollForm</code> <p>form containing data of object you wanna create.</p> required <code>options</code> <code>List[str]</code> <p>list of all options (as strings).  They must be at least 2 and at most 10.</p> required <p>Raises:</p> Type Description <code>MissingNameOrQuestionExcetion</code> <p>your form has not all required data.</p> <code>TooFewOptionsExcetion</code> <p>you put in too few options for this type of poll.</p> <code>TooManyOptionsExcetion</code> <p>you put in too many options for this type of poll.</p> <p>Returns:</p> Name Type Description <code>poll</code> <code>PollModel</code> <p>the initialized and saved PollModel object</p> Source code in <code>apps/polls_management/services/poll_create_service.py</code> <pre><code>@staticmethod\ndef create_or_edit_poll(poll_form: PollForm, options: List[str], user) -&gt; PollModel:\n\"\"\"Create a new poll starting from a PollForm object (or\n    apply the edits on the existing object)\n\n    Args:\n        poll_form: form containing data of object you wanna create.\n        options: list of all options (as strings). \n            They must be at least 2 and at most 10.\n\n    Raises:\n        MissingNameOrQuestionExcetion: your form has not all required data.\n        TooFewOptionsExcetion: you put in too few options for this type of poll.\n        TooManyOptionsExcetion: you put in too many options for this type of poll.\n\n    Returns:\n        poll: the initialized and saved PollModel object\n    \"\"\"\n    # validate form\n    if not poll_form.is_valid():\n        raise PollMainDataNotValidException(f\"Some data of passed poll_form is not valid. See errors:\\n{poll_form.errors}\")\n\n    # validate options\n    valid_options = list()\n    for o in options:\n        if o.strip() != \"\":\n            valid_options.append(o)\n\n    # ensuring is passed at least a certain number of options\n    if len(valid_options) &lt; poll_form.get_min_options():\n        raise TooFewOptionsException(f\"{poll_form.data.get('poll_type')} poll \" +\n            f\"(votable_mj={poll_form.data.get('votable_mj')}) needs at least \" +\n            f\"{poll_form.get_min_options()} options, {len(valid_options)} has given\")\n\n    # all polls can have at most 10 options\n    if len(valid_options) &gt; 10:\n        raise TooManyOptionsException(f\"A poll accepts at most 10 options, {len(valid_options)} has given\")\n\n    # create poll object from form\n    poll = poll_form.save(commit=False)\n    poll.author = user\n    poll.save()\n\n\n    # check if there are already options in the poll object\n    # and delete them (edit case)\n    if poll.options():\n        for previous_option in poll.options():\n            previous_option.delete()\n\n    # create option objects\n    for o_str in valid_options:\n        option = PollOptionModel(value=o_str)\n        option.poll_fk = poll\n        option.save()\n\n    return poll\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/","title":"Poll service (get all, delete)","text":"<p>Other CRUD options on polls.</p>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService","title":"<code>PollService</code>","text":"<p>Class to handle all poll related operations</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>class PollService:\n\"\"\"Class to handle all poll related operations\"\"\"\n\n    #TODO: check if this method is legacy\n    @staticmethod\n    def create(name: str, question: str, options: List[str], user) -&gt; PollModel: \n\"\"\"Creates a new poll.\n        Args:\n            name: Name of the poll. It has to be at least 1 characters long.\n            question: Question of the poll. It has to be at least 1 characters long.\n            options: List of options for the poll. It has to have at least 1 option.\n        Raises:\n            PollNotValidCreationException: Is raised when the poll is not valid. When the input params not meet the requirements.\n        Returns:\n            new_poll: The created poll.\n        \"\"\"\n\n        if len(name)&lt;1 or len(question)&lt;1 or len(options)&lt;1:\n            raise PollNotValidCreationException(\"Poll not valid for creation\")\n\n        new_poll: PollModel = PollModel(name=name, question=question, author=user)\n        new_poll.save()\n\n        for option in options:\n            new_option: PollOptionModel = PollOptionModel(value=option, poll_fk_id=new_poll.id)\n            new_option.save()\n\n        return new_poll\n\n    @staticmethod\n    def get_poll_by_id(id:str) -&gt; PollModel:\n\"\"\"Get a poll by id.\n        Args:\n            id: Id of the poll.\n        Raises:\n            PollDoesNotExistException: raised when you retrieve a non-existent poll.\n        Returns:\n            poll: poll object.\n        \"\"\"\n\n        try:\n            poll: PollModel = PollModel.objects.get(id=id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Error: poll with id={id} does not exit\")    \n\n        return poll\n\n    @staticmethod\n    def get_paginated_polls(page_size: int = 10) -&gt; Paginator:\n\"\"\"Get a paginated list of polls. The page size is 10 by default.\n\n        Args:\n            page_size: Number of polls per page. It has to be al least 1. By default is 10.\n\n        Raises:\n            PaginatorPageSizeException: raised when the page size is not valid. When the page size is less than 1.\n        Returns:\n            paginator: A paginator object with the polls.\n        \"\"\"\n        if page_size &lt; 1:\n            raise PaginatorPageSizeException(f\"Page size: {page_size} is not valid: It must be at least 1\")\n\n        polls: List[PollModel] = PollModel.objects.all().order_by('id')\n\n        paginator: Paginator = Paginator(polls, page_size)\n\n        return paginator\n\n    @staticmethod\n    def delete_poll(id:str):\n\"\"\"Delete a poll by id. If a poll has already been opened, it can't be deleted.\n\n        Args:\n            id: Id of the poll to delete. The poll can be a majority poll or a single option poll.\n\n        Raises:\n            PollDoesNotExistException: If the poll not exist.\n            PollIsOpenException: If the poll is open.\n\n        Returns: \n            Tuple: A tuple with first element the total number of deletions made\n            and the second element a dict with the relative details about deletion from the model perspective.\n\n        Example:\n            {3, {'polls.PollModel': 1, 'polls.PollOptionModel': 2}}\n        \"\"\"\n        try:\n            poll: PollModel = PollModel.objects.get(id=id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Poll with id={id} does not exit.\")  \n\n        if poll.is_open() or poll.is_closed():\n            raise PollIsOpenException(f\"Poll with id={id} is open.\")\n\n        return poll.delete()\n\n    @staticmethod\n    def open_poll(id:str):\n\"\"\"Open a poll by id. If a poll has already been opened, it can't be opened.\n\n        Args:\n            id: Id of the poll to open. The poll can be a majority poll or a single option poll.\n\n        Raises:\n            PollDoesNotExistException: If the poll not exist.\n            PollIsOpenException: If the poll is already open.\n            PollCannotBeOpenedException: If the poll open and close time is not valid.\n\n        Returns: \n            poll: the opened poll.\n        \"\"\"\n        try:\n            poll: PollModel = PollModel.objects.get(id=id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Poll with id={id} does not exit.\")  \n\n        if poll.is_open():\n            raise PollIsOpenException(f\"Poll with id={id} is already open.\")\n\n        if poll.open_datetime and poll.close_datetime and timezone.now() &lt; poll.close_datetime:\n            poll.open_datetime = timezone.now()\n            poll.save()\n\n            return poll\n\n        else:\n            raise PollCannotBeOpenedException(f\"Poll with id={id} cannot be opened.\")\n\n    @staticmethod\n    def user_polls(user:User) -&gt; List[PollModel]:\n\"\"\"Method used to return a list of user polls.\n\n        Args:\n            user: the user who is the author of the polls.\n\n        Returns: \n            user_poll_list: list of user polls.\n        \"\"\"\n\n        # return a list of user polls ordered by the last poll created\n        user_polls_list: List[PollModel] = list(PollModel.objects.filter(author=user).order_by('-id'))\n        return user_polls_list\n\n    @staticmethod\n    def votable_or_closed_polls() -&gt; List[PollModel]:\n\"\"\"Returns a list of votable or closed polls. The polls retuned are public by default.\n\n        Returns: \n            List of votable/closed polls.\n        \"\"\"\n\n        all_public_polls_list = PollModel.objects.filter(private=False)\n        votable_polls_list = all_public_polls_list.filter(Q(close_datetime__gte=timezone.now()) &amp; Q(open_datetime__lte=timezone.now())).order_by('close_datetime')\n        closed_polls_list = all_public_polls_list.filter(close_datetime__lte=timezone.now()).order_by('-close_datetime')\n\n        return list(votable_polls_list) + list(closed_polls_list)\n\n    @staticmethod\n    def close_poll(id:str):\n\"\"\"Close a poll by id. If a poll has already been closed, it can't be closed.\n\n        Args:\n            id: Id of the poll to close. The poll can be a majority poll or a single option poll.\n\n        Raises:\n            PollDoesNotExistException: If the poll not exist.\n            PollIsCloseException: If the poll is already close.\n\n        Returns: \n            poll: the closed poll.\n        \"\"\"\n        try:\n            poll: PollModel = PollModel.objects.get(id=id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Poll with id={id} does not exit.\")  \n\n        if poll.is_closed():\n            raise PollIsCloseException(f\"Poll with id={id} is already close.\")\n\n        if poll.is_closable_now():\n            poll.close_datetime = timezone.now()\n            poll.save()\n            return poll\n        else:\n            #poll must be open to be closed\n            raise PollCannotBeClosedException(f\"Poll with id={id} cannot be close.\")\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.close_poll","title":"<code>close_poll(id)</code>  <code>staticmethod</code>","text":"<p>Close a poll by id. If a poll has already been closed, it can't be closed.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Id of the poll to close. The poll can be a majority poll or a single option poll.</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>If the poll not exist.</p> <code>PollIsCloseException</code> <p>If the poll is already close.</p> <p>Returns:</p> Name Type Description <code>poll</code> <p>the closed poll.</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef close_poll(id:str):\n\"\"\"Close a poll by id. If a poll has already been closed, it can't be closed.\n\n    Args:\n        id: Id of the poll to close. The poll can be a majority poll or a single option poll.\n\n    Raises:\n        PollDoesNotExistException: If the poll not exist.\n        PollIsCloseException: If the poll is already close.\n\n    Returns: \n        poll: the closed poll.\n    \"\"\"\n    try:\n        poll: PollModel = PollModel.objects.get(id=id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Poll with id={id} does not exit.\")  \n\n    if poll.is_closed():\n        raise PollIsCloseException(f\"Poll with id={id} is already close.\")\n\n    if poll.is_closable_now():\n        poll.close_datetime = timezone.now()\n        poll.save()\n        return poll\n    else:\n        #poll must be open to be closed\n        raise PollCannotBeClosedException(f\"Poll with id={id} cannot be close.\")\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.create","title":"<code>create(name, question, options, user)</code>  <code>staticmethod</code>","text":"<p>Creates a new poll.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the poll. It has to be at least 1 characters long.</p> required <code>question</code> <code>str</code> <p>Question of the poll. It has to be at least 1 characters long.</p> required <code>options</code> <code>List[str]</code> <p>List of options for the poll. It has to have at least 1 option.</p> required <p>Raises:</p> Type Description <code>PollNotValidCreationException</code> <p>Is raised when the poll is not valid. When the input params not meet the requirements.</p> <p>Returns:</p> Name Type Description <code>new_poll</code> <code>PollModel</code> <p>The created poll.</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef create(name: str, question: str, options: List[str], user) -&gt; PollModel: \n\"\"\"Creates a new poll.\n    Args:\n        name: Name of the poll. It has to be at least 1 characters long.\n        question: Question of the poll. It has to be at least 1 characters long.\n        options: List of options for the poll. It has to have at least 1 option.\n    Raises:\n        PollNotValidCreationException: Is raised when the poll is not valid. When the input params not meet the requirements.\n    Returns:\n        new_poll: The created poll.\n    \"\"\"\n\n    if len(name)&lt;1 or len(question)&lt;1 or len(options)&lt;1:\n        raise PollNotValidCreationException(\"Poll not valid for creation\")\n\n    new_poll: PollModel = PollModel(name=name, question=question, author=user)\n    new_poll.save()\n\n    for option in options:\n        new_option: PollOptionModel = PollOptionModel(value=option, poll_fk_id=new_poll.id)\n        new_option.save()\n\n    return new_poll\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.delete_poll","title":"<code>delete_poll(id)</code>  <code>staticmethod</code>","text":"<p>Delete a poll by id. If a poll has already been opened, it can't be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Id of the poll to delete. The poll can be a majority poll or a single option poll.</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>If the poll not exist.</p> <code>PollIsOpenException</code> <p>If the poll is open.</p> <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A tuple with first element the total number of deletions made</p> <p>and the second element a dict with the relative details about deletion from the model perspective.</p> Example <p>{3, {'polls.PollModel': 1, 'polls.PollOptionModel': 2}}</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef delete_poll(id:str):\n\"\"\"Delete a poll by id. If a poll has already been opened, it can't be deleted.\n\n    Args:\n        id: Id of the poll to delete. The poll can be a majority poll or a single option poll.\n\n    Raises:\n        PollDoesNotExistException: If the poll not exist.\n        PollIsOpenException: If the poll is open.\n\n    Returns: \n        Tuple: A tuple with first element the total number of deletions made\n        and the second element a dict with the relative details about deletion from the model perspective.\n\n    Example:\n        {3, {'polls.PollModel': 1, 'polls.PollOptionModel': 2}}\n    \"\"\"\n    try:\n        poll: PollModel = PollModel.objects.get(id=id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Poll with id={id} does not exit.\")  \n\n    if poll.is_open() or poll.is_closed():\n        raise PollIsOpenException(f\"Poll with id={id} is open.\")\n\n    return poll.delete()\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.get_paginated_polls","title":"<code>get_paginated_polls(page_size=10)</code>  <code>staticmethod</code>","text":"<p>Get a paginated list of polls. The page size is 10 by default.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>Number of polls per page. It has to be al least 1. By default is 10.</p> <code>10</code> <p>Raises:</p> Type Description <code>PaginatorPageSizeException</code> <p>raised when the page size is not valid. When the page size is less than 1.</p> <p>Returns:</p> Name Type Description <code>paginator</code> <code>Paginator</code> <p>A paginator object with the polls.</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef get_paginated_polls(page_size: int = 10) -&gt; Paginator:\n\"\"\"Get a paginated list of polls. The page size is 10 by default.\n\n    Args:\n        page_size: Number of polls per page. It has to be al least 1. By default is 10.\n\n    Raises:\n        PaginatorPageSizeException: raised when the page size is not valid. When the page size is less than 1.\n    Returns:\n        paginator: A paginator object with the polls.\n    \"\"\"\n    if page_size &lt; 1:\n        raise PaginatorPageSizeException(f\"Page size: {page_size} is not valid: It must be at least 1\")\n\n    polls: List[PollModel] = PollModel.objects.all().order_by('id')\n\n    paginator: Paginator = Paginator(polls, page_size)\n\n    return paginator\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.get_poll_by_id","title":"<code>get_poll_by_id(id)</code>  <code>staticmethod</code>","text":"<p>Get a poll by id.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Id of the poll.</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>raised when you retrieve a non-existent poll.</p> <p>Returns:</p> Name Type Description <code>poll</code> <code>PollModel</code> <p>poll object.</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef get_poll_by_id(id:str) -&gt; PollModel:\n\"\"\"Get a poll by id.\n    Args:\n        id: Id of the poll.\n    Raises:\n        PollDoesNotExistException: raised when you retrieve a non-existent poll.\n    Returns:\n        poll: poll object.\n    \"\"\"\n\n    try:\n        poll: PollModel = PollModel.objects.get(id=id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Error: poll with id={id} does not exit\")    \n\n    return poll\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.open_poll","title":"<code>open_poll(id)</code>  <code>staticmethod</code>","text":"<p>Open a poll by id. If a poll has already been opened, it can't be opened.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Id of the poll to open. The poll can be a majority poll or a single option poll.</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>If the poll not exist.</p> <code>PollIsOpenException</code> <p>If the poll is already open.</p> <code>PollCannotBeOpenedException</code> <p>If the poll open and close time is not valid.</p> <p>Returns:</p> Name Type Description <code>poll</code> <p>the opened poll.</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef open_poll(id:str):\n\"\"\"Open a poll by id. If a poll has already been opened, it can't be opened.\n\n    Args:\n        id: Id of the poll to open. The poll can be a majority poll or a single option poll.\n\n    Raises:\n        PollDoesNotExistException: If the poll not exist.\n        PollIsOpenException: If the poll is already open.\n        PollCannotBeOpenedException: If the poll open and close time is not valid.\n\n    Returns: \n        poll: the opened poll.\n    \"\"\"\n    try:\n        poll: PollModel = PollModel.objects.get(id=id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Poll with id={id} does not exit.\")  \n\n    if poll.is_open():\n        raise PollIsOpenException(f\"Poll with id={id} is already open.\")\n\n    if poll.open_datetime and poll.close_datetime and timezone.now() &lt; poll.close_datetime:\n        poll.open_datetime = timezone.now()\n        poll.save()\n\n        return poll\n\n    else:\n        raise PollCannotBeOpenedException(f\"Poll with id={id} cannot be opened.\")\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.user_polls","title":"<code>user_polls(user)</code>  <code>staticmethod</code>","text":"<p>Method used to return a list of user polls.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>the user who is the author of the polls.</p> required <p>Returns:</p> Name Type Description <code>user_poll_list</code> <code>List[PollModel]</code> <p>list of user polls.</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef user_polls(user:User) -&gt; List[PollModel]:\n\"\"\"Method used to return a list of user polls.\n\n    Args:\n        user: the user who is the author of the polls.\n\n    Returns: \n        user_poll_list: list of user polls.\n    \"\"\"\n\n    # return a list of user polls ordered by the last poll created\n    user_polls_list: List[PollModel] = list(PollModel.objects.filter(author=user).order_by('-id'))\n    return user_polls_list\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_service/#apps.polls_management.services.poll_service.PollService.votable_or_closed_polls","title":"<code>votable_or_closed_polls()</code>  <code>staticmethod</code>","text":"<p>Returns a list of votable or closed polls. The polls retuned are public by default.</p> <p>Returns:</p> Type Description <code>List[PollModel]</code> <p>List of votable/closed polls.</p> Source code in <code>apps/polls_management/services/poll_service.py</code> <pre><code>@staticmethod\ndef votable_or_closed_polls() -&gt; List[PollModel]:\n\"\"\"Returns a list of votable or closed polls. The polls retuned are public by default.\n\n    Returns: \n        List of votable/closed polls.\n    \"\"\"\n\n    all_public_polls_list = PollModel.objects.filter(private=False)\n    votable_polls_list = all_public_polls_list.filter(Q(close_datetime__gte=timezone.now()) &amp; Q(open_datetime__lte=timezone.now())).order_by('close_datetime')\n    closed_polls_list = all_public_polls_list.filter(close_datetime__lte=timezone.now()).order_by('-close_datetime')\n\n    return list(votable_polls_list) + list(closed_polls_list)\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/","title":"Poll Token Service","text":"<p>Services related to tokens generations and management.</p>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService","title":"<code>PollTokenService</code>","text":"<p>Service class for poll tokens management</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>class PollTokenService:\n\n\"\"\"Service class for poll tokens management\"\"\"\n\n    @staticmethod\n    def create_tokens(token_number: int, poll: PollModel) -&gt; List[PollTokens]:\n\n\"\"\"Create tokens for the poll and store them in the database.\n        Args:\n            token_number: number of tokens to create.\n            poll: poll to assign tokens created.\n        Returns:\n            tokens: list of tokens created.\n        \"\"\"\n\n        tokens: List[PollTokens] = []\n\n        # creation of a token link for as many times as dictated\n        for x in range(token_number):\n\n            # creation of a phantom user to assign a token and database integrity control\n            # (if a user with the same name already exists)\n            unique_id = get_random_string(length=8)\n            while (User.objects.filter(username=unique_id).exists()):\n                unique_id = get_random_string(length=8)\n\n            phantomuser: User = User.objects.create_user(username=unique_id)\n\n            # creation of database table for new token\n            new_token: PollTokens = PollTokens(token_user=phantomuser, poll_fk=poll)\n            new_token.save()\n\n            tokens.append(new_token)\n\n        return tokens\n\n    @staticmethod\n    def get_poll_token_by_user(user: User) -&gt; PollTokens:\n\n\"\"\"Get a poll token by its user.\n        Args:\n            user: user whom the token is assigned to.\n        Raises:\n            TokenDoesNotExistException: raised when you retrieve a non-existent token.\n        Returns:\n            poll_token: token associated with the user.\n        \"\"\"\n\n        try:\n            poll_token: PollTokens = PollTokens.objects.get(token_user=user)\n        except ObjectDoesNotExist:\n            raise TokenDoesNotExistException(f\"Error: token with user={user} does not exit\")    \n\n        return poll_token\n\n    @staticmethod\n    def is_single_option_token_used(token: PollTokens) -&gt; bool:\n\n\"\"\"Check if a token is used for a single option poll.\n        Args:\n            token: token model with all necessary information.\n        Returns:\n            Bool indicating if token is used for a single option poll or not.\n        \"\"\"\n\n        if token.single_option_use:\n            return True\n        else:\n            return False\n\n    @staticmethod\n    def is_majority_token_used(token: PollTokens) -&gt; bool:\n\n\"\"\"Check if a token is used for a majority poll.\n        Args:\n            token: token model with all necessary information.\n        Returns:\n            Bool indicating if token is used for a majority judgment poll or not.\n        \"\"\"\n\n        if token.majority_use:\n            return True\n        else:\n            return False\n\n    @staticmethod\n    def check_single_option(token: PollTokens):\n\n\"\"\"Make token for single option as already used.\n        Args:\n            token: token model with all necessary information.\n        \"\"\"\n\n        token.single_option_use = True\n        token.save()\n\n    @staticmethod\n    def check_majority_option(token: PollTokens):\n\n\"\"\"Make token for majority option as already used.\n        Args:\n            token: token model with all necessary information.\n        \"\"\"\n\n        token.majority_use = True\n        token.save()\n\n    @staticmethod\n    def available_token_list(poll: PollModel) -&gt; List[PollTokens]:\n\n\"\"\"Return a list of available tokens.\n        Args:\n            poll: the poll the tokens belong to.\n        Returns:\n            List of available token links.\n        \"\"\"\n\n        return PollTokens.objects.filter(\n                Q(poll_fk=poll) &amp; Q(single_option_use=False) \n                &amp; Q(majority_use=False)\n            ).order_by('-created_at').all()\n\n    def delete_tokens(poll: PollModel):\n\n\"\"\"Delete tokens and related phantom users for the specified list.\n        Args:\n            poll: the poll the tokens belong to.\n        \"\"\"\n\n        # get all tokens for the specified poll, be them available or not\n        tokens: PollTokens = PollTokens.objects.filter(poll_fk=poll)\n\n        # if there are tokens for the poll, delete the phantom users and then their tokens\n        if tokens:\n            for token in tokens:\n                phantouser: User = token.token_user\n                phantouser.delete()\n                token.delete()\n\n    @staticmethod\n    def unavailable_token_list(poll: PollModel) -&gt; List[PollTokens]:\n\n\"\"\"Return a list of unavailable token links.\n        Args:\n            poll: the poll the tokens belong to.\n        Returns:\n            List of unavailable token links.\n        \"\"\"\n\n        return PollTokens.objects.filter(Q(poll_fk=poll) &amp; Q(Q(single_option_use=True) | Q(majority_use=True))).all()\n\n    @staticmethod\n    def create_google_record(user: User, poll: PollModel) -&gt; PollTokens:\n\n\"\"\"Creates an object PollTokens used to record a vote for a Google auth user.\n        Args:\n            user: the user whose vote has to be recorded.\n            poll: the poll the tokens belong to.\n        Returns:\n            google_vote: the token representing the user's vote with Google email.\n        \"\"\"\n\n        google_vote: PollTokens = PollTokens(token_user=user, poll_fk=poll)\n        google_vote.save()\n\n        return google_vote\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.available_token_list","title":"<code>available_token_list(poll)</code>  <code>staticmethod</code>","text":"<p>Return a list of available tokens.</p> <p>Parameters:</p> Name Type Description Default <code>poll</code> <code>PollModel</code> <p>the poll the tokens belong to.</p> required <p>Returns:</p> Type Description <code>List[PollTokens]</code> <p>List of available token links.</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef available_token_list(poll: PollModel) -&gt; List[PollTokens]:\n\n\"\"\"Return a list of available tokens.\n    Args:\n        poll: the poll the tokens belong to.\n    Returns:\n        List of available token links.\n    \"\"\"\n\n    return PollTokens.objects.filter(\n            Q(poll_fk=poll) &amp; Q(single_option_use=False) \n            &amp; Q(majority_use=False)\n        ).order_by('-created_at').all()\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.check_majority_option","title":"<code>check_majority_option(token)</code>  <code>staticmethod</code>","text":"<p>Make token for majority option as already used.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>PollTokens</code> <p>token model with all necessary information.</p> required Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef check_majority_option(token: PollTokens):\n\n\"\"\"Make token for majority option as already used.\n    Args:\n        token: token model with all necessary information.\n    \"\"\"\n\n    token.majority_use = True\n    token.save()\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.check_single_option","title":"<code>check_single_option(token)</code>  <code>staticmethod</code>","text":"<p>Make token for single option as already used.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>PollTokens</code> <p>token model with all necessary information.</p> required Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef check_single_option(token: PollTokens):\n\n\"\"\"Make token for single option as already used.\n    Args:\n        token: token model with all necessary information.\n    \"\"\"\n\n    token.single_option_use = True\n    token.save()\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.create_google_record","title":"<code>create_google_record(user, poll)</code>  <code>staticmethod</code>","text":"<p>Creates an object PollTokens used to record a vote for a Google auth user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>the user whose vote has to be recorded.</p> required <code>poll</code> <code>PollModel</code> <p>the poll the tokens belong to.</p> required <p>Returns:</p> Name Type Description <code>google_vote</code> <code>PollTokens</code> <p>the token representing the user's vote with Google email.</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef create_google_record(user: User, poll: PollModel) -&gt; PollTokens:\n\n\"\"\"Creates an object PollTokens used to record a vote for a Google auth user.\n    Args:\n        user: the user whose vote has to be recorded.\n        poll: the poll the tokens belong to.\n    Returns:\n        google_vote: the token representing the user's vote with Google email.\n    \"\"\"\n\n    google_vote: PollTokens = PollTokens(token_user=user, poll_fk=poll)\n    google_vote.save()\n\n    return google_vote\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.create_tokens","title":"<code>create_tokens(token_number, poll)</code>  <code>staticmethod</code>","text":"<p>Create tokens for the poll and store them in the database.</p> <p>Parameters:</p> Name Type Description Default <code>token_number</code> <code>int</code> <p>number of tokens to create.</p> required <code>poll</code> <code>PollModel</code> <p>poll to assign tokens created.</p> required <p>Returns:</p> Name Type Description <code>tokens</code> <code>List[PollTokens]</code> <p>list of tokens created.</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef create_tokens(token_number: int, poll: PollModel) -&gt; List[PollTokens]:\n\n\"\"\"Create tokens for the poll and store them in the database.\n    Args:\n        token_number: number of tokens to create.\n        poll: poll to assign tokens created.\n    Returns:\n        tokens: list of tokens created.\n    \"\"\"\n\n    tokens: List[PollTokens] = []\n\n    # creation of a token link for as many times as dictated\n    for x in range(token_number):\n\n        # creation of a phantom user to assign a token and database integrity control\n        # (if a user with the same name already exists)\n        unique_id = get_random_string(length=8)\n        while (User.objects.filter(username=unique_id).exists()):\n            unique_id = get_random_string(length=8)\n\n        phantomuser: User = User.objects.create_user(username=unique_id)\n\n        # creation of database table for new token\n        new_token: PollTokens = PollTokens(token_user=phantomuser, poll_fk=poll)\n        new_token.save()\n\n        tokens.append(new_token)\n\n    return tokens\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.delete_tokens","title":"<code>delete_tokens(poll)</code>","text":"<p>Delete tokens and related phantom users for the specified list.</p> <p>Parameters:</p> Name Type Description Default <code>poll</code> <code>PollModel</code> <p>the poll the tokens belong to.</p> required Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>def delete_tokens(poll: PollModel):\n\n\"\"\"Delete tokens and related phantom users for the specified list.\n    Args:\n        poll: the poll the tokens belong to.\n    \"\"\"\n\n    # get all tokens for the specified poll, be them available or not\n    tokens: PollTokens = PollTokens.objects.filter(poll_fk=poll)\n\n    # if there are tokens for the poll, delete the phantom users and then their tokens\n    if tokens:\n        for token in tokens:\n            phantouser: User = token.token_user\n            phantouser.delete()\n            token.delete()\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.get_poll_token_by_user","title":"<code>get_poll_token_by_user(user)</code>  <code>staticmethod</code>","text":"<p>Get a poll token by its user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>user whom the token is assigned to.</p> required <p>Raises:</p> Type Description <code>TokenDoesNotExistException</code> <p>raised when you retrieve a non-existent token.</p> <p>Returns:</p> Name Type Description <code>poll_token</code> <code>PollTokens</code> <p>token associated with the user.</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef get_poll_token_by_user(user: User) -&gt; PollTokens:\n\n\"\"\"Get a poll token by its user.\n    Args:\n        user: user whom the token is assigned to.\n    Raises:\n        TokenDoesNotExistException: raised when you retrieve a non-existent token.\n    Returns:\n        poll_token: token associated with the user.\n    \"\"\"\n\n    try:\n        poll_token: PollTokens = PollTokens.objects.get(token_user=user)\n    except ObjectDoesNotExist:\n        raise TokenDoesNotExistException(f\"Error: token with user={user} does not exit\")    \n\n    return poll_token\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.is_majority_token_used","title":"<code>is_majority_token_used(token)</code>  <code>staticmethod</code>","text":"<p>Check if a token is used for a majority poll.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>PollTokens</code> <p>token model with all necessary information.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Bool indicating if token is used for a majority judgment poll or not.</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef is_majority_token_used(token: PollTokens) -&gt; bool:\n\n\"\"\"Check if a token is used for a majority poll.\n    Args:\n        token: token model with all necessary information.\n    Returns:\n        Bool indicating if token is used for a majority judgment poll or not.\n    \"\"\"\n\n    if token.majority_use:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.is_single_option_token_used","title":"<code>is_single_option_token_used(token)</code>  <code>staticmethod</code>","text":"<p>Check if a token is used for a single option poll.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>PollTokens</code> <p>token model with all necessary information.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Bool indicating if token is used for a single option poll or not.</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef is_single_option_token_used(token: PollTokens) -&gt; bool:\n\n\"\"\"Check if a token is used for a single option poll.\n    Args:\n        token: token model with all necessary information.\n    Returns:\n        Bool indicating if token is used for a single option poll or not.\n    \"\"\"\n\n    if token.single_option_use:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"code_documentation/polls_management/services/poll_token_service/#apps.polls_management.services.poll_token_service.PollTokenService.unavailable_token_list","title":"<code>unavailable_token_list(poll)</code>  <code>staticmethod</code>","text":"<p>Return a list of unavailable token links.</p> <p>Parameters:</p> Name Type Description Default <code>poll</code> <code>PollModel</code> <p>the poll the tokens belong to.</p> required <p>Returns:</p> Type Description <code>List[PollTokens]</code> <p>List of unavailable token links.</p> Source code in <code>apps/polls_management/services/poll_token_service.py</code> <pre><code>@staticmethod\ndef unavailable_token_list(poll: PollModel) -&gt; List[PollTokens]:\n\n\"\"\"Return a list of unavailable token links.\n    Args:\n        poll: the poll the tokens belong to.\n    Returns:\n        List of unavailable token links.\n    \"\"\"\n\n    return PollTokens.objects.filter(Q(poll_fk=poll) &amp; Q(Q(single_option_use=True) | Q(majority_use=True))).all()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/","title":"Majority Poll Result Data","text":"<p>Tool class used to create a results object instance for majority judgment polls.</p>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData","title":"<code>MajorityPollResultData</code>  <code>dataclass</code>","text":"<p>         Bases: <code>object</code></p> <p>Small class used to store the data related to the results of a majority poll</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>@dataclass\nclass MajorityPollResultData(object):\n\"\"\"Small class used to store the data related to\n    the results of a majority poll\"\"\"\n\n    option: PollOptionModel\n\"\"\"The poll_option the data is related to\"\"\"\n\n    good_votes: int\n\"\"\"The number of good votes performed to this option\"\"\"\n\n    median: int\n\"\"\"The majority grade of the option/poll, called as a median\n    of the value of the votes\"\"\"\n\n    bad_votes: int\n\"\"\"The number of bad votes performed to this option\"\"\"\n\n    positive_grade: bool\n\"\"\"The majority grade sign is '+' if good votes are more than\n    bad votes\"\"\"\n\n    option_votes: QuerySet\n\"\"\"All the votes for this option\"\"\"\n\n    def __init__(self, option: PollOptionModel):\n\n        self.option = option\n\n        # retrieve votes (ordered by rating)\n        self.option_votes = MajorityJudgmentModel.objects \\\n            .filter(poll_option=option.id) \\\n            .order_by('rating')\n\n        if self.option_votes.count() &lt; 1:\n            raise PollNotYetVodedException()\n\n        # calculate median (or worse of two)\n        self.median = self.option_votes[math.floor((self.option_votes.count()-1)/2)].rating\n\n        # retrieve number of (strictly) greater and smaller votes\n        self.good_votes: int = self.option_votes.filter(rating__gt=self.median).count()\n        self.bad_votes: int = self.option_votes.filter(rating__lt=self.median).count()\n\n        # set sign: \n        # if good &gt; bad         --&gt; +\n        # else if good &lt;= bad   --&gt; -\n        self.positive_grade = (self.good_votes &gt; self.bad_votes)\n\n    def get_qualitative_median(self) -&gt; str:\n\"\"\"Get median value as a qualitative judjment\"\"\"\n        return self.get_qualitative(self.median)\n\n    def get_qualitative(self, rating) -&gt; str:\n        range = ['Pessimo', 'Insufficiente', 'Sufficiente', 'Buono', 'Ottimo']\n        return range[rating-1]\n\n    def get_sign(self) -&gt; str:\n\"\"\"Get sign (as symbol)\"\"\"\n        return \"+\" if self.positive_grade else \"-\"\n\n    def get_judjment_percentages(self) -&gt; list[dict]: \n\"\"\"Get percentage of judjments of each value\"\"\"\n\n        all_votes = MajorityJudgmentModel.objects \\\n            .filter(poll_option=self.option)\n\n        all_votes_n = float(all_votes.count())\n\n        colors = ['#E41A1C', '#FE8E3C', '#FFFFCD', '#7FCEBC', '#253495']\n        textcolors = ['white', 'white', 'black', 'black', 'white']\n\n        res: list[dict] = []\n        for i in range(1,6):\n            value = float(all_votes.filter(rating=i).count())/all_votes_n\n            if value &gt; 0:\n                res.append({\n                    'value': value, \n                    'percentage': int(value*100), \n                    'style': f\"background-color:{colors[i-1]}; color: {textcolors[i-1]}; \", \n                    'label': self.get_qualitative(i), \n                })\n\n        return res\n\n\n    def __eq__(self, other): \n\n        if not isinstance(other, MajorityPollResultData):\n            raise Exception(\"Cannot compare MajorityPollResultData with other type\")\n\n        return self.compare(other) == 0\n\n    def __gt__(self, other):\n\"\"\"\n        Check if my rating is better than other\n        (so if I am semantically \"&gt;\" than the other one)\n        \"\"\"\n\n        if not isinstance(other, MajorityPollResultData):\n            raise Exception(\"Cannot compare MajorityPollResultData with other type\")\n\n        cmp = self.compare(other)\n        return cmp &gt; 0 if cmp != 0 else self.option.value &gt; other.option.value\n\n    def majority_values_median(self, values: list[MajorityJudgmentModel]) -&gt; int:\n\"\"\"Returns new median from list of majority values\"\"\"\n\n        old_median = values[math.floor(len(values)/2)]\n\n        if len(values) &gt; 1:\n            # here we exclude the single value of the median\n            values.remove(old_median)\n            new_median = values[math.floor(len(values)/2)].rating\n\n            return new_median\n        else:\n            return old_median\n\n    def median_value(self, iteration=0) -&gt; int:\n\"\"\"Calculates the median of the current majority values iteration\"\"\"\n\n        majority_values = list(self.option_votes)\n        majority_values.sort(key=lambda x: x.rating)\n\n        median_idx = math.floor((len(majority_values)-1)/2)\n        median = majority_values[median_idx].rating\n\n        while iteration &gt; 0:\n            del majority_values[median_idx]\n            iteration -= 1 \n            median_idx = math.floor((len(majority_values)-1)/2)\n            median = majority_values[median_idx].rating\n\n        return median\n\n    def sorting(self, obj, i) -&gt; bool:\n\"\"\"Function that gives sorting rules for Majority Poll Result Data Objects\"\"\"\n\n        if i == self.option_votes.count():\n            return self.option.value &lt; obj.option.value\n\n        # if median is greater --&gt; x win\n        if self.median_value(iteration=i) &gt; obj.median_value(iteration=i):\n            return True\n        elif self.median_value(iteration=i) &lt; obj.median_value(iteration=i):\n            return False\n        else:\n            return self.sorting(obj, i+1)\n\n    def compare(self, obj, i=0):\n\"\"\"returns 1 if self &gt; obj, -1 if self &lt; obj, 0 if self == obj\"\"\"\n\n        if i == self.option_votes.count():\n            return 0\n\n        # if median is greater --&gt; x win\n        self_median = self.median_value(iteration=i)\n        obj_median = obj.median_value(iteration=i)\n\n        if self_median &gt; obj_median:\n            return +1\n        elif self_median &lt; obj_median:\n            return -1\n        else:\n            return self.compare(obj, i+1)\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.bad_votes","title":"<code>bad_votes: int = self.option_votes.filter(rating__lt=self.median).count()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of bad votes performed to this option</p>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.good_votes","title":"<code>good_votes: int = self.option_votes.filter(rating__gt=self.median).count()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of good votes performed to this option</p>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.median","title":"<code>median = self.option_votes[math.floor(self.option_votes.count() - 1 / 2)].rating</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The majority grade of the option/poll, called as a median of the value of the votes</p>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.option","title":"<code>option = option</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The poll_option the data is related to</p>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.option_votes","title":"<code>option_votes = MajorityJudgmentModel.objects.filter(poll_option=option.id).order_by('rating')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the votes for this option</p>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.positive_grade","title":"<code>positive_grade = self.good_votes &gt; self.bad_votes</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The majority grade sign is '+' if good votes are more than bad votes</p>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Check if my rating is better than other (so if I am semantically \"&gt;\" than the other one)</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def __gt__(self, other):\n\"\"\"\n    Check if my rating is better than other\n    (so if I am semantically \"&gt;\" than the other one)\n    \"\"\"\n\n    if not isinstance(other, MajorityPollResultData):\n        raise Exception(\"Cannot compare MajorityPollResultData with other type\")\n\n    cmp = self.compare(other)\n    return cmp &gt; 0 if cmp != 0 else self.option.value &gt; other.option.value\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.compare","title":"<code>compare(obj, i=0)</code>","text":"<p>returns 1 if self &gt; obj, -1 if self &lt; obj, 0 if self == obj</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def compare(self, obj, i=0):\n\"\"\"returns 1 if self &gt; obj, -1 if self &lt; obj, 0 if self == obj\"\"\"\n\n    if i == self.option_votes.count():\n        return 0\n\n    # if median is greater --&gt; x win\n    self_median = self.median_value(iteration=i)\n    obj_median = obj.median_value(iteration=i)\n\n    if self_median &gt; obj_median:\n        return +1\n    elif self_median &lt; obj_median:\n        return -1\n    else:\n        return self.compare(obj, i+1)\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.get_judjment_percentages","title":"<code>get_judjment_percentages()</code>","text":"<p>Get percentage of judjments of each value</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def get_judjment_percentages(self) -&gt; list[dict]: \n\"\"\"Get percentage of judjments of each value\"\"\"\n\n    all_votes = MajorityJudgmentModel.objects \\\n        .filter(poll_option=self.option)\n\n    all_votes_n = float(all_votes.count())\n\n    colors = ['#E41A1C', '#FE8E3C', '#FFFFCD', '#7FCEBC', '#253495']\n    textcolors = ['white', 'white', 'black', 'black', 'white']\n\n    res: list[dict] = []\n    for i in range(1,6):\n        value = float(all_votes.filter(rating=i).count())/all_votes_n\n        if value &gt; 0:\n            res.append({\n                'value': value, \n                'percentage': int(value*100), \n                'style': f\"background-color:{colors[i-1]}; color: {textcolors[i-1]}; \", \n                'label': self.get_qualitative(i), \n            })\n\n    return res\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.get_qualitative_median","title":"<code>get_qualitative_median()</code>","text":"<p>Get median value as a qualitative judjment</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def get_qualitative_median(self) -&gt; str:\n\"\"\"Get median value as a qualitative judjment\"\"\"\n    return self.get_qualitative(self.median)\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.get_sign","title":"<code>get_sign()</code>","text":"<p>Get sign (as symbol)</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def get_sign(self) -&gt; str:\n\"\"\"Get sign (as symbol)\"\"\"\n    return \"+\" if self.positive_grade else \"-\"\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.majority_values_median","title":"<code>majority_values_median(values)</code>","text":"<p>Returns new median from list of majority values</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def majority_values_median(self, values: list[MajorityJudgmentModel]) -&gt; int:\n\"\"\"Returns new median from list of majority values\"\"\"\n\n    old_median = values[math.floor(len(values)/2)]\n\n    if len(values) &gt; 1:\n        # here we exclude the single value of the median\n        values.remove(old_median)\n        new_median = values[math.floor(len(values)/2)].rating\n\n        return new_median\n    else:\n        return old_median\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.median_value","title":"<code>median_value(iteration=0)</code>","text":"<p>Calculates the median of the current majority values iteration</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def median_value(self, iteration=0) -&gt; int:\n\"\"\"Calculates the median of the current majority values iteration\"\"\"\n\n    majority_values = list(self.option_votes)\n    majority_values.sort(key=lambda x: x.rating)\n\n    median_idx = math.floor((len(majority_values)-1)/2)\n    median = majority_values[median_idx].rating\n\n    while iteration &gt; 0:\n        del majority_values[median_idx]\n        iteration -= 1 \n        median_idx = math.floor((len(majority_values)-1)/2)\n        median = majority_values[median_idx].rating\n\n    return median\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_poll_result_data/#apps.votes_results.classes.majority_poll_result_data.MajorityPollResultData.sorting","title":"<code>sorting(obj, i)</code>","text":"<p>Function that gives sorting rules for Majority Poll Result Data Objects</p> Source code in <code>apps/votes_results/classes/majority_poll_result_data.py</code> <pre><code>def sorting(self, obj, i) -&gt; bool:\n\"\"\"Function that gives sorting rules for Majority Poll Result Data Objects\"\"\"\n\n    if i == self.option_votes.count():\n        return self.option.value &lt; obj.option.value\n\n    # if median is greater --&gt; x win\n    if self.median_value(iteration=i) &gt; obj.median_value(iteration=i):\n        return True\n    elif self.median_value(iteration=i) &lt; obj.median_value(iteration=i):\n        return False\n    else:\n        return self.sorting(obj, i+1)\n</code></pre>"},{"location":"code_documentation/votes_results/classes/mj_vote_counter/","title":"Majority Judgment vote counter","text":"<p>Vote counter for mj votes votes</p>"},{"location":"code_documentation/votes_results/classes/mj_vote_counter/#apps.votes_results.classes.mj_vote_counter.MjVoteCounter","title":"<code>MjVoteCounter</code>","text":"<p>Class to count votes for a single option poll.</p> Source code in <code>apps/votes_results/classes/mj_vote_counter.py</code> <pre><code>class MjVoteCounter:\n\"\"\"Class to count votes for a single option poll.\"\"\"\n    def __init__(self, poll: PollModel):\n        self._poll: PollModel = poll\n\n    def count_majority_judgment_votes(self):\n\"\"\"Count votes for a majority judgment poll.\n            Returns:\n                int: Number of votes.\n        \"\"\"\n\n        votes: MajorityVoteModel = MajorityVoteModel.objects.filter(poll=self._poll.id)\n\n        return len(votes)\n</code></pre>"},{"location":"code_documentation/votes_results/classes/mj_vote_counter/#apps.votes_results.classes.mj_vote_counter.MjVoteCounter.count_majority_judgment_votes","title":"<code>count_majority_judgment_votes()</code>","text":"<p>Count votes for a majority judgment poll.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of votes.</p> Source code in <code>apps/votes_results/classes/mj_vote_counter.py</code> <pre><code>def count_majority_judgment_votes(self):\n\"\"\"Count votes for a majority judgment poll.\n        Returns:\n            int: Number of votes.\n    \"\"\"\n\n    votes: MajorityVoteModel = MajorityVoteModel.objects.filter(poll=self._poll.id)\n\n    return len(votes)\n</code></pre>"},{"location":"code_documentation/votes_results/classes/poll_result/","title":"Poll Result","text":"<p>Tool class used to create a results object instance for single option polls.</p>"},{"location":"code_documentation/votes_results/classes/poll_result/#apps.votes_results.classes.poll_result.PollResult","title":"<code>PollResult</code>  <code>dataclass</code>","text":"<p>Compute a result of a closed poll.</p> Source code in <code>apps/votes_results/classes/poll_result.py</code> <pre><code>@dataclass\nclass PollResult: \n\"\"\"\n    Compute a result of a closed poll. \n    \"\"\"\n\n    poll: PollModel\n\"\"\"\n    The poll the result is about\n    \"\"\"\n\n\n    def __init__(self, poll: PollModel) -&gt; None:\n        self.poll: PollModel = poll\n        self.__memoized_result: Optional[List[PollResultVoice]] = None\n\n    def get_sorted_options(self) -&gt; List[PollResultVoice]:\n\"\"\"\n        Result as an ordered list of pairs (choice, n_votes).\n\n        Result is computed only once for efficiency reasons (and then memoized). \n        If you want to compute it again, create another PollResult instance.\n        \"\"\"\n\n        # if it exists, return memoized result\n        if self.__memoized_result is not None:\n            return self.__memoized_result\n\n        # calculate result\n        self.__memoized_result = []\n        for option in PollOptionModel.objects.filter(poll_fk=self.poll.id).all():\n            self.__memoized_result.append(PollResultVoice(option))\n\n        # sort by (decreasing) n votes\n        def n_votes(voice: PollResultVoice):\n            return voice.n_votes\n        self.__memoized_result.sort(reverse=True, key=n_votes)\n\n\n        index =0 \n        aux_n_position=[]\n        pos = 1 #temporary position\n        n_pos = 1 #number of option on the same position\n        for option in self.__memoized_result:\n            if(index==0):\n                option.position=pos\n            elif(self.__memoized_result[index-1].n_votes==option.n_votes):\n                option.position=pos\n                n_pos+=1\n            else:\n                pos += n_pos\n                option.position = pos\n                n_pos=1\n            aux_n_position.append([pos,option])\n            index += 1\n\n        index = 0\n        n_position=[]\n        while index &lt;len(aux_n_position)-1:\n            if(aux_n_position[index][0]!=aux_n_position[index+1][0]):\n                n_position.append(aux_n_position[index])\n            index+=1\n        n_position.append(aux_n_position[-1])\n\n        return {\"results\":self.__memoized_result,\n                \"positions\":n_position\n                }\n</code></pre>"},{"location":"code_documentation/votes_results/classes/poll_result/#apps.votes_results.classes.poll_result.PollResult.poll","title":"<code>poll: PollModel = poll</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The poll the result is about</p>"},{"location":"code_documentation/votes_results/classes/poll_result/#apps.votes_results.classes.poll_result.PollResult.get_sorted_options","title":"<code>get_sorted_options()</code>","text":"<p>Result as an ordered list of pairs (choice, n_votes).</p> <p>Result is computed only once for efficiency reasons (and then memoized).  If you want to compute it again, create another PollResult instance.</p> Source code in <code>apps/votes_results/classes/poll_result.py</code> <pre><code>def get_sorted_options(self) -&gt; List[PollResultVoice]:\n\"\"\"\n    Result as an ordered list of pairs (choice, n_votes).\n\n    Result is computed only once for efficiency reasons (and then memoized). \n    If you want to compute it again, create another PollResult instance.\n    \"\"\"\n\n    # if it exists, return memoized result\n    if self.__memoized_result is not None:\n        return self.__memoized_result\n\n    # calculate result\n    self.__memoized_result = []\n    for option in PollOptionModel.objects.filter(poll_fk=self.poll.id).all():\n        self.__memoized_result.append(PollResultVoice(option))\n\n    # sort by (decreasing) n votes\n    def n_votes(voice: PollResultVoice):\n        return voice.n_votes\n    self.__memoized_result.sort(reverse=True, key=n_votes)\n\n\n    index =0 \n    aux_n_position=[]\n    pos = 1 #temporary position\n    n_pos = 1 #number of option on the same position\n    for option in self.__memoized_result:\n        if(index==0):\n            option.position=pos\n        elif(self.__memoized_result[index-1].n_votes==option.n_votes):\n            option.position=pos\n            n_pos+=1\n        else:\n            pos += n_pos\n            option.position = pos\n            n_pos=1\n        aux_n_position.append([pos,option])\n        index += 1\n\n    index = 0\n    n_position=[]\n    while index &lt;len(aux_n_position)-1:\n        if(aux_n_position[index][0]!=aux_n_position[index+1][0]):\n            n_position.append(aux_n_position[index])\n        index+=1\n    n_position.append(aux_n_position[-1])\n\n    return {\"results\":self.__memoized_result,\n            \"positions\":n_position\n            }\n</code></pre>"},{"location":"code_documentation/votes_results/classes/poll_result/#apps.votes_results.classes.poll_result.PollResultVoice","title":"<code>PollResultVoice</code>  <code>dataclass</code>","text":"<p>A single voice of the result. It's made of a PollOption and the number of received votes.</p> <p>N votes are calculated during object building.</p> Source code in <code>apps/votes_results/classes/poll_result.py</code> <pre><code>@dataclass\nclass PollResultVoice:\n\"\"\"\n    A single voice of the result. It's made of a PollOption and the number\n    of received votes.\n\n    N votes are calculated during object building.\n    \"\"\"\n\n    n_votes: int\n\"\"\"\n    Number of votes the option received\n    \"\"\"\n\n    option: PollOptionModel\n\"\"\"\n    The voted option\n    \"\"\"\n    position:int\n\"\"\"\n    Position in results\n    \"\"\"\n\n\n    def __init__(self, poll_option: PollOptionModel) -&gt; None:\n        self.n_votes = PollResultVoice.__count_n_votes(poll_option)\n        self.position = 0\n        self.option = poll_option\n\n    @staticmethod\n    def __count_n_votes(poll_option: PollOptionModel) -&gt; int:\n        return VoteModel.objects.filter(poll_option=poll_option.id).count()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/poll_result/#apps.votes_results.classes.poll_result.PollResultVoice.n_votes","title":"<code>n_votes = PollResultVoice.__count_n_votes(poll_option)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of votes the option received</p>"},{"location":"code_documentation/votes_results/classes/poll_result/#apps.votes_results.classes.poll_result.PollResultVoice.option","title":"<code>option = poll_option</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The voted option</p>"},{"location":"code_documentation/votes_results/classes/poll_result/#apps.votes_results.classes.poll_result.PollResultVoice.position","title":"<code>position = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Position in results</p>"},{"location":"code_documentation/votes_results/classes/vote_builder/","title":"Vote Builder","text":"<p>Tool class used to create a vote instance for single option polls.</p>"},{"location":"code_documentation/votes_results/classes/vote_builder/#apps.votes_results.classes.vote_builder.VoteBuilder","title":"<code>VoteBuilder</code>","text":"<p>A tool that will help you building a VoteModel instance. </p> <p>To use it: - create an instance - use method set_poll(poll_id) to set the poll you want to vote - use method set_poll_option(poll_option_id) to set voted option - use perform_creation to confirm your choice and generate the model   (call it just once)</p> <p>If something goes wrong, proper exception will be thrown.</p> <p>At end of process object is NOT saved (call save() to do so)</p> Source code in <code>apps/votes_results/classes/vote_builder.py</code> <pre><code>class VoteBuilder:\n\"\"\"\n    A tool that will help you building a VoteModel instance. \n\n    To use it:\n    - create an instance\n    - use method set_poll(poll_id) to set the poll you want to vote\n    - use method set_poll_option(poll_option_id) to set voted option\n    - use perform_creation to confirm your choice and generate the model\n      (call it just once)\n\n    If something goes wrong, proper exception will be thrown.\n\n    At end of process object is NOT saved (call save() to do so)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.__voted_option = None\n        self.__poll = None\n        self.__vote_model = None\n\n\n    def set_poll(self, poll_id: str) -&gt; \"VoteBuilder\":\n\"\"\"\n        Set the poll you want to vote. It resets choosed option\n        Args:\n            poll_id: poll you want to vote\n        Raises:\n            PollDoesNotExistException: you passed a not existent poll\n        \"\"\"\n\n        self.__voted_option = None\n\n        try:\n            self.__poll: PollModel = PollModel.objects.get(id=poll_id)\n            # todo: add here \"is open\" filter\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Error: Poll with id={poll_id} does not exist\")\n\n        return self\n\n    def set_voted_option(self, poll_option_id: str) -&gt; \"VoteBuilder\":\n\"\"\"\n        Set the option you want to vote\n        Args:\n            poll_option_id: your choice you want to vote\n        Raises:\n            PollOptionUnvalidException: you passed an option that does not belong to poll\n                or you passed a not existent option\n        \"\"\"\n\n        try:\n            self.__voted_option: PollOptionModel = PollOptionModel.objects \\\n                .filter(poll_fk=self.__poll.id) \\\n                .get(id=poll_option_id)\n\n        except ObjectDoesNotExist:\n            raise PollOptionUnvalidException(f\"Error: PollOption with id={poll_option_id} does \" +\n            f\"not exist or it is not related to Poll with id={self.__poll.id}\")\n\n        return self\n\n    def perform_creation(self) -&gt; VoteModel:\n\"\"\"\n        Create VoteModel instance using passed (and validated) poll and option. \n        instance is not yet saved. Call save() to store it in DB.\n        Raises:\n            PollDoesNotExistException: poll is unvalid\n            PollOptionUnvalidException: poll option is unvalid\n        \"\"\"\n\n        if self.__poll is None:\n            raise PollDoesNotExistException()\n        if self.__voted_option is None:\n            raise PollOptionUnvalidException()\n\n        if self.__vote_model is not None:\n            return self.__vote_model\n\n        self.__vote_model = VoteModel(poll_option=self.__voted_option)\n\n        return self.__vote_model\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_builder/#apps.votes_results.classes.vote_builder.VoteBuilder.perform_creation","title":"<code>perform_creation()</code>","text":"<p>Create VoteModel instance using passed (and validated) poll and option.  instance is not yet saved. Call save() to store it in DB.</p> <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>poll is unvalid</p> <code>PollOptionUnvalidException</code> <p>poll option is unvalid</p> Source code in <code>apps/votes_results/classes/vote_builder.py</code> <pre><code>def perform_creation(self) -&gt; VoteModel:\n\"\"\"\n    Create VoteModel instance using passed (and validated) poll and option. \n    instance is not yet saved. Call save() to store it in DB.\n    Raises:\n        PollDoesNotExistException: poll is unvalid\n        PollOptionUnvalidException: poll option is unvalid\n    \"\"\"\n\n    if self.__poll is None:\n        raise PollDoesNotExistException()\n    if self.__voted_option is None:\n        raise PollOptionUnvalidException()\n\n    if self.__vote_model is not None:\n        return self.__vote_model\n\n    self.__vote_model = VoteModel(poll_option=self.__voted_option)\n\n    return self.__vote_model\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_builder/#apps.votes_results.classes.vote_builder.VoteBuilder.set_poll","title":"<code>set_poll(poll_id)</code>","text":"<p>Set the poll you want to vote. It resets choosed option</p> <p>Parameters:</p> Name Type Description Default <code>poll_id</code> <code>str</code> <p>poll you want to vote</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>you passed a not existent poll</p> Source code in <code>apps/votes_results/classes/vote_builder.py</code> <pre><code>def set_poll(self, poll_id: str) -&gt; \"VoteBuilder\":\n\"\"\"\n    Set the poll you want to vote. It resets choosed option\n    Args:\n        poll_id: poll you want to vote\n    Raises:\n        PollDoesNotExistException: you passed a not existent poll\n    \"\"\"\n\n    self.__voted_option = None\n\n    try:\n        self.__poll: PollModel = PollModel.objects.get(id=poll_id)\n        # todo: add here \"is open\" filter\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Error: Poll with id={poll_id} does not exist\")\n\n    return self\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_builder/#apps.votes_results.classes.vote_builder.VoteBuilder.set_voted_option","title":"<code>set_voted_option(poll_option_id)</code>","text":"<p>Set the option you want to vote</p> <p>Parameters:</p> Name Type Description Default <code>poll_option_id</code> <code>str</code> <p>your choice you want to vote</p> required <p>Raises:</p> Type Description <code>PollOptionUnvalidException</code> <p>you passed an option that does not belong to poll or you passed a not existent option</p> Source code in <code>apps/votes_results/classes/vote_builder.py</code> <pre><code>def set_voted_option(self, poll_option_id: str) -&gt; \"VoteBuilder\":\n\"\"\"\n    Set the option you want to vote\n    Args:\n        poll_option_id: your choice you want to vote\n    Raises:\n        PollOptionUnvalidException: you passed an option that does not belong to poll\n            or you passed a not existent option\n    \"\"\"\n\n    try:\n        self.__voted_option: PollOptionModel = PollOptionModel.objects \\\n            .filter(poll_fk=self.__poll.id) \\\n            .get(id=poll_option_id)\n\n    except ObjectDoesNotExist:\n        raise PollOptionUnvalidException(f\"Error: PollOption with id={poll_option_id} does \" +\n        f\"not exist or it is not related to Poll with id={self.__poll.id}\")\n\n    return self\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_judgment_results/i_majority_judment_results/","title":"I-Majority Judgment Results","text":"<p>Abstract class to manage parity in majority judgment results.</p>"},{"location":"code_documentation/votes_results/classes/majority_judgment_results/i_majority_judment_results/#apps.votes_results.classes.majority_judgment_results.i_majority_judment_results.IMajorityJudgmentResults","title":"<code>IMajorityJudgmentResults</code>","text":"<p>         Bases: <code>abc.ABC</code></p> <p>The expected schema for Majority Judgment voting results. It provides a method to calculate the results + some information getters that will be used in template</p> Source code in <code>apps/votes_results/classes/majority_judgment_results/i_majority_judment_results.py</code> <pre><code>class IMajorityJudgmentResults(abc.ABC):\n\"\"\"The expected schema for Majority Judgment voting\n      results. It provides a method to calculate the results\n      + some information getters that will be used in template\"\"\"\n\n\n    def __init__(self, poll: PollModel) -&gt; None:\n        self.poll = poll  \n\n    @abc.abstractmethod\n    def calculate(self) -&gt; None:\n\"\"\"Do once the calculation of the results and store all\n        information locally (so you avoid to repeat DB queries \n        and heavy calculations)\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_votes(self) -&gt; List[MajorityVoteModel]:\n\"\"\"Return the list of all submitted votes.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_sorted_options(self) -&gt; List[List[MajorityPollResultData]]:\n\"\"\"The actual sorted algorithm results, from the better option\n        to the worse. We use a list of list because there could be equal \n        scores.\"\"\"\n        pass\n\n    def get_sorted_options_no_parity(self) -&gt; List[MajorityPollResultData]:\n\n        res = self.get_sorted_options()\n\n        poll_results: List[MajorityPollResultData] = []\n        for p in res:\n            for r in p:\n                poll_results.append(r)\n\n        return poll_results\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_judgment_results/i_majority_judment_results/#apps.votes_results.classes.majority_judgment_results.i_majority_judment_results.IMajorityJudgmentResults.calculate","title":"<code>calculate()</code>  <code>abstractmethod</code>","text":"<p>Do once the calculation of the results and store all information locally (so you avoid to repeat DB queries  and heavy calculations)</p> Source code in <code>apps/votes_results/classes/majority_judgment_results/i_majority_judment_results.py</code> <pre><code>@abc.abstractmethod\ndef calculate(self) -&gt; None:\n\"\"\"Do once the calculation of the results and store all\n    information locally (so you avoid to repeat DB queries \n    and heavy calculations)\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_judgment_results/i_majority_judment_results/#apps.votes_results.classes.majority_judgment_results.i_majority_judment_results.IMajorityJudgmentResults.get_sorted_options","title":"<code>get_sorted_options()</code>  <code>abstractmethod</code>","text":"<p>The actual sorted algorithm results, from the better option to the worse. We use a list of list because there could be equal  scores.</p> Source code in <code>apps/votes_results/classes/majority_judgment_results/i_majority_judment_results.py</code> <pre><code>@abc.abstractmethod\ndef get_sorted_options(self) -&gt; List[List[MajorityPollResultData]]:\n\"\"\"The actual sorted algorithm results, from the better option\n    to the worse. We use a list of list because there could be equal \n    scores.\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_judgment_results/i_majority_judment_results/#apps.votes_results.classes.majority_judgment_results.i_majority_judment_results.IMajorityJudgmentResults.get_votes","title":"<code>get_votes()</code>  <code>abstractmethod</code>","text":"<p>Return the list of all submitted votes.</p> Source code in <code>apps/votes_results/classes/majority_judgment_results/i_majority_judment_results.py</code> <pre><code>@abc.abstractmethod\ndef get_votes(self) -&gt; List[MajorityVoteModel]:\n\"\"\"Return the list of all submitted votes.\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/majority_judgment_results/no_parity_mj_results/","title":"No parity MJ Results","text":"<p>Class to manage results when no parity in majority judgment results.</p>"},{"location":"code_documentation/votes_results/classes/majority_judgment_results/parity_mj_results/","title":"Parity MJ Results","text":"<p>Class to manage parity in majority judgment results.</p>"},{"location":"code_documentation/votes_results/classes/schulze_results/i_schulze_results/","title":"I-Schulze Results","text":"<p>Abstract class used to create a schulze results object instance for schulze polls.</p>"},{"location":"code_documentation/votes_results/classes/schulze_results/i_schulze_results/#apps.votes_results.classes.schulze_results.i_schulze_results.ISchulzeResults","title":"<code>ISchulzeResults</code>","text":"<p>         Bases: <code>abc.ABC</code></p> <p>The expected schema for Schulze voting results. It  provides a method to calculate the results + some information  getters that will be used in template to render results.</p> <p>It is the type expected by the Schulze results service.</p> Source code in <code>apps/votes_results/classes/schulze_results/i_schulze_results.py</code> <pre><code>class ISchulzeResults(abc.ABC):\n\"\"\"The expected schema for Schulze voting results. It \n    provides a method to calculate the results + some information \n    getters that will be used in template to render results.\n\n    It is the type expected by the Schulze results service.\"\"\"\n\n    def __init__(self, poll: PollModel) -&gt; None:\n        self.poll = poll        \n\n    @abc.abstractmethod\n    def calculate(self) -&gt; None:\n\"\"\"Do once the calculation of the results and store all\n        information locally (so you avoid to repeat DB queries \n        and heavy calculations)\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_votes(self) -&gt; List[SchulzeVoteModel]:\n\"\"\"Return the list of all submitted votes.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_sorted_options(self) -&gt; List[List[PollOptionModel]]:\n\"\"\"The actual sorted algorithm results, from the better option\n        to the worse. We use a list of list because there could be equal \n        scores.\"\"\"\n        pass\n\n    def get_preference_matrix_cell(self, a: PollOptionModel, b: PollOptionModel) -&gt; List[int]:\n\"\"\"Return the number of times a is prefered to b.\"\"\"\n\n        if a == b:\n            return \"/\"\n\n        count = 0\n        for vote in self.get_votes():\n            order = vote.get_order()\n            if order.index(str(a.id)) &lt; order.index(str(b.id)):\n                count += 1\n        return count\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/i_schulze_results/#apps.votes_results.classes.schulze_results.i_schulze_results.ISchulzeResults.calculate","title":"<code>calculate()</code>  <code>abstractmethod</code>","text":"<p>Do once the calculation of the results and store all information locally (so you avoid to repeat DB queries  and heavy calculations)</p> Source code in <code>apps/votes_results/classes/schulze_results/i_schulze_results.py</code> <pre><code>@abc.abstractmethod\ndef calculate(self) -&gt; None:\n\"\"\"Do once the calculation of the results and store all\n    information locally (so you avoid to repeat DB queries \n    and heavy calculations)\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/i_schulze_results/#apps.votes_results.classes.schulze_results.i_schulze_results.ISchulzeResults.get_preference_matrix_cell","title":"<code>get_preference_matrix_cell(a, b)</code>","text":"<p>Return the number of times a is prefered to b.</p> Source code in <code>apps/votes_results/classes/schulze_results/i_schulze_results.py</code> <pre><code>def get_preference_matrix_cell(self, a: PollOptionModel, b: PollOptionModel) -&gt; List[int]:\n\"\"\"Return the number of times a is prefered to b.\"\"\"\n\n    if a == b:\n        return \"/\"\n\n    count = 0\n    for vote in self.get_votes():\n        order = vote.get_order()\n        if order.index(str(a.id)) &lt; order.index(str(b.id)):\n            count += 1\n    return count\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/i_schulze_results/#apps.votes_results.classes.schulze_results.i_schulze_results.ISchulzeResults.get_sorted_options","title":"<code>get_sorted_options()</code>  <code>abstractmethod</code>","text":"<p>The actual sorted algorithm results, from the better option to the worse. We use a list of list because there could be equal  scores.</p> Source code in <code>apps/votes_results/classes/schulze_results/i_schulze_results.py</code> <pre><code>@abc.abstractmethod\ndef get_sorted_options(self) -&gt; List[List[PollOptionModel]]:\n\"\"\"The actual sorted algorithm results, from the better option\n    to the worse. We use a list of list because there could be equal \n    scores.\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/i_schulze_results/#apps.votes_results.classes.schulze_results.i_schulze_results.ISchulzeResults.get_votes","title":"<code>get_votes()</code>  <code>abstractmethod</code>","text":"<p>Return the list of all submitted votes.</p> Source code in <code>apps/votes_results/classes/schulze_results/i_schulze_results.py</code> <pre><code>@abc.abstractmethod\ndef get_votes(self) -&gt; List[SchulzeVoteModel]:\n\"\"\"Return the list of all submitted votes.\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/","title":"Schulze Results Adapter","text":"<p>Class used to create a schulze results object instance for schulze polls.</p>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter","title":"<code>SchulzeResultsAdapter</code>","text":"<p>         Bases: <code>ISchulzeResults</code></p> <p>Class used to manage data for a Schulze poll results</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>class SchulzeResultsAdapter(ISchulzeResults):\n\"\"\"Class used to manage data for a Schulze poll results\"\"\"\n\n    schulze_votes: List[SchulzeVoteModel]\n\"\"\"List containing all the votes for the specified schulze poll.\"\"\"\n\n    schulze_results: List[List[PollOptionModel]]\n\"\"\"List containing all the results in the winning order.\"\"\"\n\n    schulze_str_options: List[str]\n\"\"\"List containing all the options of the poll as list of string ids.\"\"\"\n\n    all_schulze_rankings: List[List[List[str]]]\n\"\"\"List containing all the order rankings of the poll as list of string ids.\"\"\"\n\n    def get_votes(self) -&gt; List[SchulzeVoteModel]:\n\"\"\"Returns all the schulze votes of the poll as list\"\"\"\n        return self.schulze_votes\n\n    def get_sorted_options(self) -&gt; List[List[PollOptionModel]]:\n\"\"\"Returns the schulze poll results as list of List of PollOptionModel (in case of parity)\"\"\"\n        return self.schulze_results\n\n    def calculate(self) -&gt; None:\n\"\"\"Populates the class variables from the poll\"\"\"\n\n        self.set_votes()\n        self.set_options()\n        self.set_all_rankings()\n        # now we have all the elements to calcluate the results with the algorithm\n        self.set_schulze_results()\n\n    def set_votes(self) -&gt; None:\n\"\"\"Populates the votes list\"\"\"\n\n        try:\n            self.schulze_votes = list(SchulzeVoteModel.objects.filter(poll=self.poll))\n        except ObjectDoesNotExist:\n            raise VoteDoesNotExistException(f\"The vote model does not exist.\")\n\n        if len(self.schulze_votes) &lt; 1:\n            raise PollNotYetVodedException()\n\n    def set_options(self) -&gt; None:\n\"\"\"Populates options list as string of ids\"\"\"\n        self.schulze_str_options = self.schulze_votes[0].get_order_as_ids()\n\n    def set_all_rankings(self) -&gt; None:\n\"\"\"Populates the list of all ranks\"\"\"\n\n        all_rankings: List[List[List[str]]] = []\n        for vote in self.schulze_votes:\n            vote_list: List[List[str]] = [[i] for i in vote.get_order()]\n            all_rankings.append(vote_list)\n\n        self.all_schulze_rankings = all_rankings\n\n    def set_schulze_results(self) -&gt; None:\n\"\"\"Calculates all the results\"\"\"\n\n        # from the schulze algorithm, we need to \"candidate names\" and \"ballots\"\n        # respectively 'schulze_str_options' and 'all_schulze_rankings'\n        result: List[List[str]] = schulze.compute_schulze_ranking(self.schulze_str_options, self.all_schulze_rankings)\n\n        rankings: List[List[PollOptionModel]] = []\n        for id in result:\n            same_rank_list: List[PollOptionModel] = []\n            for same_rank in id:\n                option: PollOptionModel = PollOptionModel.objects.get(id=int(same_rank))\n                same_rank_list.append(option)\n            rankings.append(same_rank_list)\n\n        self.schulze_results = rankings\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.all_schulze_rankings","title":"<code>all_schulze_rankings: List[List[List[str]]]</code>  <code>class-attribute</code>","text":"<p>List containing all the order rankings of the poll as list of string ids.</p>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.schulze_results","title":"<code>schulze_results: List[List[PollOptionModel]]</code>  <code>class-attribute</code>","text":"<p>List containing all the results in the winning order.</p>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.schulze_str_options","title":"<code>schulze_str_options: List[str]</code>  <code>class-attribute</code>","text":"<p>List containing all the options of the poll as list of string ids.</p>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.schulze_votes","title":"<code>schulze_votes: List[SchulzeVoteModel]</code>  <code>class-attribute</code>","text":"<p>List containing all the votes for the specified schulze poll.</p>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.calculate","title":"<code>calculate()</code>","text":"<p>Populates the class variables from the poll</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>def calculate(self) -&gt; None:\n\"\"\"Populates the class variables from the poll\"\"\"\n\n    self.set_votes()\n    self.set_options()\n    self.set_all_rankings()\n    # now we have all the elements to calcluate the results with the algorithm\n    self.set_schulze_results()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.get_sorted_options","title":"<code>get_sorted_options()</code>","text":"<p>Returns the schulze poll results as list of List of PollOptionModel (in case of parity)</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>def get_sorted_options(self) -&gt; List[List[PollOptionModel]]:\n\"\"\"Returns the schulze poll results as list of List of PollOptionModel (in case of parity)\"\"\"\n    return self.schulze_results\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.get_votes","title":"<code>get_votes()</code>","text":"<p>Returns all the schulze votes of the poll as list</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>def get_votes(self) -&gt; List[SchulzeVoteModel]:\n\"\"\"Returns all the schulze votes of the poll as list\"\"\"\n    return self.schulze_votes\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.set_all_rankings","title":"<code>set_all_rankings()</code>","text":"<p>Populates the list of all ranks</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>def set_all_rankings(self) -&gt; None:\n\"\"\"Populates the list of all ranks\"\"\"\n\n    all_rankings: List[List[List[str]]] = []\n    for vote in self.schulze_votes:\n        vote_list: List[List[str]] = [[i] for i in vote.get_order()]\n        all_rankings.append(vote_list)\n\n    self.all_schulze_rankings = all_rankings\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.set_options","title":"<code>set_options()</code>","text":"<p>Populates options list as string of ids</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>def set_options(self) -&gt; None:\n\"\"\"Populates options list as string of ids\"\"\"\n    self.schulze_str_options = self.schulze_votes[0].get_order_as_ids()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.set_schulze_results","title":"<code>set_schulze_results()</code>","text":"<p>Calculates all the results</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>def set_schulze_results(self) -&gt; None:\n\"\"\"Calculates all the results\"\"\"\n\n    # from the schulze algorithm, we need to \"candidate names\" and \"ballots\"\n    # respectively 'schulze_str_options' and 'all_schulze_rankings'\n    result: List[List[str]] = schulze.compute_schulze_ranking(self.schulze_str_options, self.all_schulze_rankings)\n\n    rankings: List[List[PollOptionModel]] = []\n    for id in result:\n        same_rank_list: List[PollOptionModel] = []\n        for same_rank in id:\n            option: PollOptionModel = PollOptionModel.objects.get(id=int(same_rank))\n            same_rank_list.append(option)\n        rankings.append(same_rank_list)\n\n    self.schulze_results = rankings\n</code></pre>"},{"location":"code_documentation/votes_results/classes/schulze_results/schulze_results_adapter/#apps.votes_results.classes.schulze_results.schulze_results_adapter.SchulzeResultsAdapter.set_votes","title":"<code>set_votes()</code>","text":"<p>Populates the votes list</p> Source code in <code>apps/votes_results/classes/schulze_results/schulze_results_adapter.py</code> <pre><code>def set_votes(self) -&gt; None:\n\"\"\"Populates the votes list\"\"\"\n\n    try:\n        self.schulze_votes = list(SchulzeVoteModel.objects.filter(poll=self.poll))\n    except ObjectDoesNotExist:\n        raise VoteDoesNotExistException(f\"The vote model does not exist.\")\n\n    if len(self.schulze_votes) &lt; 1:\n        raise PollNotYetVodedException()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_poll_votable_checker/","title":"Is Poll Votable Checker","text":"<p>Class used to check if poll is votable.</p>"},{"location":"code_documentation/votes_results/classes/vote/is_poll_votable_checker/#apps.votes_results.classes.vote.is_poll_votable_checker.IsPollVotableChecker","title":"<code>IsPollVotableChecker</code>","text":"<p>A class  that contains all the checks to ensure a poll is votable now.</p> <p>Each method, makes a check and returns True if the check is passed, False otherwise.</p> Source code in <code>apps/votes_results/classes/vote/is_poll_votable_checker.py</code> <pre><code>class IsPollVotableChecker:\n\"\"\"\n    A class  that contains all the checks to ensure a poll is votable now.\n\n    Each method, makes a check and returns True if the check is passed, False otherwise.\n    \"\"\"\n\n    poll: PollModel = None\n\n    def load_poll(self, poll_id) -&gt; bool:\n\"\"\"Load the poll with the given id (ensure it exists)\"\"\"\n\n        if poll_id is None:\n            return False\n\n        try:\n            self.poll: PollModel = PollService.get_poll_by_id(poll_id)\n            return True\n        except PollDoesNotExistException:\n            return False\n\n    def is_poll_open_for_votes(self) -&gt; bool:\n\"\"\"Check if curr date is in the dates interval where poll is open for vote\"\"\"\n        return self.poll.is_open() and not self.poll.is_closed()\n\n    def is_poll_votable_through_method(self, votemethod: PollModel.PollType) -&gt; bool:\n\"\"\"Check if the poll is votable through the given method\"\"\"\n\n        if self.poll.poll_type == votemethod:\n            return True # same vote method --&gt; OK\n\n        # else I check the special case \"votable also w MJ\"\n        return self.poll.is_votable_w_so_and_mj()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_poll_votable_checker/#apps.votes_results.classes.vote.is_poll_votable_checker.IsPollVotableChecker.is_poll_open_for_votes","title":"<code>is_poll_open_for_votes()</code>","text":"<p>Check if curr date is in the dates interval where poll is open for vote</p> Source code in <code>apps/votes_results/classes/vote/is_poll_votable_checker.py</code> <pre><code>def is_poll_open_for_votes(self) -&gt; bool:\n\"\"\"Check if curr date is in the dates interval where poll is open for vote\"\"\"\n    return self.poll.is_open() and not self.poll.is_closed()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_poll_votable_checker/#apps.votes_results.classes.vote.is_poll_votable_checker.IsPollVotableChecker.is_poll_votable_through_method","title":"<code>is_poll_votable_through_method(votemethod)</code>","text":"<p>Check if the poll is votable through the given method</p> Source code in <code>apps/votes_results/classes/vote/is_poll_votable_checker.py</code> <pre><code>def is_poll_votable_through_method(self, votemethod: PollModel.PollType) -&gt; bool:\n\"\"\"Check if the poll is votable through the given method\"\"\"\n\n    if self.poll.poll_type == votemethod:\n        return True # same vote method --&gt; OK\n\n    # else I check the special case \"votable also w MJ\"\n    return self.poll.is_votable_w_so_and_mj()\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_poll_votable_checker/#apps.votes_results.classes.vote.is_poll_votable_checker.IsPollVotableChecker.load_poll","title":"<code>load_poll(poll_id)</code>","text":"<p>Load the poll with the given id (ensure it exists)</p> Source code in <code>apps/votes_results/classes/vote/is_poll_votable_checker.py</code> <pre><code>def load_poll(self, poll_id) -&gt; bool:\n\"\"\"Load the poll with the given id (ensure it exists)\"\"\"\n\n    if poll_id is None:\n        return False\n\n    try:\n        self.poll: PollModel = PollService.get_poll_by_id(poll_id)\n        return True\n    except PollDoesNotExistException:\n        return False\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_user_allowed_checker/","title":"Is User Allowed Checker","text":"<p>Class used to check if poll is votable by the user.</p>"},{"location":"code_documentation/votes_results/classes/vote/is_user_allowed_checker/#apps.votes_results.classes.vote.is_user_allowed_checker.IsUserAllowedChecker","title":"<code>IsUserAllowedChecker</code>","text":"<p>         Bases: <code>abc.ABC</code></p> Source code in <code>apps/votes_results/classes/vote/is_user_allowed_checker.py</code> <pre><code>class IsUserAllowedChecker(abc.ABC): \n\n    @abc.abstractmethod\n    def is_user_allowed(self) -&gt; bool: \n\"\"\"Check current user is allowed to access the poll\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def is_user_allowed_for_votemethod(self, votemethod: PollModel.PollType) -&gt; bool: \n\"\"\"Check current user is allowed to submit \n        a vote with a certain votemethod\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def is_voted_so_but_not_mj(self) -&gt; bool:\n\"\"\"Check a poll is voted (by this user) w\n        SO but not with MJ. It is used to handle \n        the special double vote case.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def mark_votemethod_as_used(self, votemethod: PollModel.PollType) -&gt; None:\n\"\"\"Save that a certain votemethod has been used \n        for current user/token.\"\"\"\n        pass \n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_user_allowed_checker/#apps.votes_results.classes.vote.is_user_allowed_checker.IsUserAllowedChecker.is_user_allowed","title":"<code>is_user_allowed()</code>  <code>abstractmethod</code>","text":"<p>Check current user is allowed to access the poll</p> Source code in <code>apps/votes_results/classes/vote/is_user_allowed_checker.py</code> <pre><code>@abc.abstractmethod\ndef is_user_allowed(self) -&gt; bool: \n\"\"\"Check current user is allowed to access the poll\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_user_allowed_checker/#apps.votes_results.classes.vote.is_user_allowed_checker.IsUserAllowedChecker.is_user_allowed_for_votemethod","title":"<code>is_user_allowed_for_votemethod(votemethod)</code>  <code>abstractmethod</code>","text":"<p>Check current user is allowed to submit  a vote with a certain votemethod</p> Source code in <code>apps/votes_results/classes/vote/is_user_allowed_checker.py</code> <pre><code>@abc.abstractmethod\ndef is_user_allowed_for_votemethod(self, votemethod: PollModel.PollType) -&gt; bool: \n\"\"\"Check current user is allowed to submit \n    a vote with a certain votemethod\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_user_allowed_checker/#apps.votes_results.classes.vote.is_user_allowed_checker.IsUserAllowedChecker.is_voted_so_but_not_mj","title":"<code>is_voted_so_but_not_mj()</code>  <code>abstractmethod</code>","text":"<p>Check a poll is voted (by this user) w SO but not with MJ. It is used to handle  the special double vote case.</p> Source code in <code>apps/votes_results/classes/vote/is_user_allowed_checker.py</code> <pre><code>@abc.abstractmethod\ndef is_voted_so_but_not_mj(self) -&gt; bool:\n\"\"\"Check a poll is voted (by this user) w\n    SO but not with MJ. It is used to handle \n    the special double vote case.\"\"\"\n    pass\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/is_user_allowed_checker/#apps.votes_results.classes.vote.is_user_allowed_checker.IsUserAllowedChecker.mark_votemethod_as_used","title":"<code>mark_votemethod_as_used(votemethod)</code>  <code>abstractmethod</code>","text":"<p>Save that a certain votemethod has been used  for current user/token.</p> Source code in <code>apps/votes_results/classes/vote/is_user_allowed_checker.py</code> <pre><code>@abc.abstractmethod\ndef mark_votemethod_as_used(self, votemethod: PollModel.PollType) -&gt; None:\n\"\"\"Save that a certain votemethod has been used \n    for current user/token.\"\"\"\n    pass \n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/token_validator/","title":"Token Validator","text":"<p>Class used to check if poll token is valid.</p>"},{"location":"code_documentation/votes_results/classes/vote/token_validator/#apps.votes_results.classes.vote.token_validator.TokenValidator","title":"<code>TokenValidator</code>","text":"<p>A tool to validate a token using a sequence of steps</p> Source code in <code>apps/votes_results/classes/vote/token_validator.py</code> <pre><code>class TokenValidator:\n\"\"\"A tool to validate a token using a sequence of steps\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.token = NoToken()\n\n    def load_token_from_user(self, user, poll: PollModel):\n\n        try:\n            self.token = PollTokens.objects.get(\n                token_user=user, poll_fk = poll)\n        except ObjectDoesNotExist:\n            self.token = NoToken()\n\n    def is_token_load(self):\n        return not isinstance(self.token, NoToken)\n\n    def is_token_valid(self): \n        return not isinstance(self.token, NoToken)\n\n    def is_token_available_for_votemethod(self, votemethod: PollModel.PollType) -&gt; bool:\n\n        if (votemethod == PollModel.PollType.SINGLE_OPTION) or \\\n            (votemethod == PollModel.PollType.SCHULZE):\n            return not self.token.single_option_use\n\n        if votemethod == PollModel.PollType.MAJORITY_JUDJMENT:\n            return not self.token.majority_use\n\n        return False\n\n    def is_token_voted_so_but_not_mj(self) -&gt; bool:\n\n        if not self.is_token_load():\n            return False\n\n        return self.token.single_option_use and not self.token.majority_use\n\n    def mark_votemethod_as_used(self, votemethod: PollModel.PollType):\n\n        if not self.is_token_load():\n            raise Exception(\"Cannot mark a token as used if it's not load\")\n\n        if (votemethod == PollModel.PollType.SINGLE_OPTION) or \\\n            (votemethod == PollModel.PollType.SCHULZE):\n            if self.token.single_option_use:\n                raise Exception(\"Cannot vote two times with same method (single option)\")\n\n            self.token.single_option_use = True\n            self.token.save()\n            return\n\n        if votemethod == PollModel.PollType.MAJORITY_JUDJMENT:\n            if self.token.majority_use:\n                raise Exception(\"Cannot vote two times with same method (majority judgment)\")\n\n            self.token.majority_use = True\n            self.token.save()\n            return\n\n        raise Exception(\"Unvalid votemethod\")\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote/vote_template_names/","title":"vote Template Names","text":"<p>Redirect template if user is not logged or has already voted.</p>"},{"location":"code_documentation/votes_results/classes/vote/vote_template_names/#apps.votes_results.classes.vote.vote_template_names.nonauth_user_template_name","title":"<code>nonauth_user_template_name(poll)</code>","text":"<p>Name of template to display if user is not  authorized to perform a vote</p> Source code in <code>apps/votes_results/classes/vote/vote_template_names.py</code> <pre><code>def nonauth_user_template_name(poll: PollModel) -&gt; str:\n\"\"\"Name of template to display if user is not \n    authorized to perform a vote\"\"\"\n\n    if poll.is_votable_google():\n        return 'global/login.html'\n\n    return 'polls_management/token_poll_redirect.html'\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_mj_vote/","title":"Check Consistency MJ Vote","text":"<p>Class used to check if there is a conflict between a single option and majority judgment vote for polls also votable with MJ.</p>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_mj_vote/#apps.votes_results.classes.vote_consistency.check_consistency_mj_vote.CheckConsistencyMjVote","title":"<code>CheckConsistencyMjVote</code>","text":"Source code in <code>apps/votes_results/classes/vote_consistency/check_consistency_mj_vote.py</code> <pre><code>class CheckConsistencyMjVote:\n\n    @staticmethod    \n    def check(single_option_vote_key: str, mj_votes: List[dict]) -&gt; bool:\n\"\"\"Checks if the single option vote key is consistent with the majority judgment votes.\n\n        Args:\n            single_option_vote_key (str): Single option vote id.\n            mj_votes (List[dict]): List of dicts with mj keys and ratings. Example: [{'poll_choice_id': 1, 'rating': 3}, {'poll_choice_id': 2, 'rating': 2}]\n\n        Returns:\n            bool: True if the single option vote key is consistent with the majority judgment votes, False otherwise.\n        \"\"\"\n        if mj_votes:\n            max_rating: dict = [max(mj_votes, key=lambda x:x['rating'])]\n            items_with_max_rating: List[dict] = [item for item in mj_votes if item['rating'] == max_rating[0]['rating']]\n        else:\n            return False\n\n        for item in items_with_max_rating:\n            if item['poll_choice_id'] == int(single_option_vote_key):\n                return True\n        return False\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_mj_vote/#apps.votes_results.classes.vote_consistency.check_consistency_mj_vote.CheckConsistencyMjVote.check","title":"<code>check(single_option_vote_key, mj_votes)</code>  <code>staticmethod</code>","text":"<p>Checks if the single option vote key is consistent with the majority judgment votes.</p> <p>Parameters:</p> Name Type Description Default <code>single_option_vote_key</code> <code>str</code> <p>Single option vote id.</p> required <code>mj_votes</code> <code>List[dict]</code> <p>List of dicts with mj keys and ratings. Example: [{'poll_choice_id': 1, 'rating': 3}, {'poll_choice_id': 2, 'rating': 2}]</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the single option vote key is consistent with the majority judgment votes, False otherwise.</p> Source code in <code>apps/votes_results/classes/vote_consistency/check_consistency_mj_vote.py</code> <pre><code>@staticmethod    \ndef check(single_option_vote_key: str, mj_votes: List[dict]) -&gt; bool:\n\"\"\"Checks if the single option vote key is consistent with the majority judgment votes.\n\n    Args:\n        single_option_vote_key (str): Single option vote id.\n        mj_votes (List[dict]): List of dicts with mj keys and ratings. Example: [{'poll_choice_id': 1, 'rating': 3}, {'poll_choice_id': 2, 'rating': 2}]\n\n    Returns:\n        bool: True if the single option vote key is consistent with the majority judgment votes, False otherwise.\n    \"\"\"\n    if mj_votes:\n        max_rating: dict = [max(mj_votes, key=lambda x:x['rating'])]\n        items_with_max_rating: List[dict] = [item for item in mj_votes if item['rating'] == max_rating[0]['rating']]\n    else:\n        return False\n\n    for item in items_with_max_rating:\n        if item['poll_choice_id'] == int(single_option_vote_key):\n            return True\n    return False\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_schulze/","title":"Check Consistency Schulze","text":"<p>Class used to check if there is a conflict between a schulze method and majority judgment vote for polls also votable with MJ.</p>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_schulze/#apps.votes_results.classes.vote_consistency.check_consistency_shulze.CheckConsistencyShulze","title":"<code>CheckConsistencyShulze</code>","text":"Source code in <code>apps/votes_results/classes/vote_consistency/check_consistency_shulze.py</code> <pre><code>class CheckConsistencyShulze:\n\n    @staticmethod    \n    def check(shulze_vote_id: str, mj_votes: List[dict]) -&gt; bool:\n\"\"\"Checks if the shulze vote key is consistent with the majority judgment votes.\n\n        Args:\n            shulze_vote_id (str): Shulze vote option vote id.\n            mj_votes (List[dict]): List of dicts with mj keys and ratings. Example: [{'poll_choice_id': 1, 'rating': 3}, {'poll_choice_id': 2, 'rating': 2}]\n\n        Returns:\n            bool: True if the Shulze option vote key is consistent with the majority judgment votes, False otherwise.\n        \"\"\"\n        if shulze_vote_id != None:\n            try:\n                vote = SchulzeMethodVoteService.get_vote_by_id(shulze_vote_id)\n                shulze_options: list = vote.get_order()\n\n                for shulze_options_index in range(0, len(vote.get_order()) - 1):\n                    previous_rating: list= list(filter(lambda x: x['poll_choice_id'] == int(shulze_options[shulze_options_index]), mj_votes ))[0]['rating']\n                    next_rating: list = list(filter(lambda x: x['poll_choice_id'] == int(shulze_options[shulze_options_index + 1]), mj_votes ))[0]['rating']\n\n                    if previous_rating &lt; next_rating:\n                        return False\n            except Exception as e:\n                # If the poll is not found, the vote is not consistent\n                return False\n        return True\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_schulze/#apps.votes_results.classes.vote_consistency.check_consistency_shulze.CheckConsistencyShulze.check","title":"<code>check(shulze_vote_id, mj_votes)</code>  <code>staticmethod</code>","text":"<p>Checks if the shulze vote key is consistent with the majority judgment votes.</p> <p>Parameters:</p> Name Type Description Default <code>shulze_vote_id</code> <code>str</code> <p>Shulze vote option vote id.</p> required <code>mj_votes</code> <code>List[dict]</code> <p>List of dicts with mj keys and ratings. Example: [{'poll_choice_id': 1, 'rating': 3}, {'poll_choice_id': 2, 'rating': 2}]</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Shulze option vote key is consistent with the majority judgment votes, False otherwise.</p> Source code in <code>apps/votes_results/classes/vote_consistency/check_consistency_shulze.py</code> <pre><code>@staticmethod    \ndef check(shulze_vote_id: str, mj_votes: List[dict]) -&gt; bool:\n\"\"\"Checks if the shulze vote key is consistent with the majority judgment votes.\n\n    Args:\n        shulze_vote_id (str): Shulze vote option vote id.\n        mj_votes (List[dict]): List of dicts with mj keys and ratings. Example: [{'poll_choice_id': 1, 'rating': 3}, {'poll_choice_id': 2, 'rating': 2}]\n\n    Returns:\n        bool: True if the Shulze option vote key is consistent with the majority judgment votes, False otherwise.\n    \"\"\"\n    if shulze_vote_id != None:\n        try:\n            vote = SchulzeMethodVoteService.get_vote_by_id(shulze_vote_id)\n            shulze_options: list = vote.get_order()\n\n            for shulze_options_index in range(0, len(vote.get_order()) - 1):\n                previous_rating: list= list(filter(lambda x: x['poll_choice_id'] == int(shulze_options[shulze_options_index]), mj_votes ))[0]['rating']\n                next_rating: list = list(filter(lambda x: x['poll_choice_id'] == int(shulze_options[shulze_options_index + 1]), mj_votes ))[0]['rating']\n\n                if previous_rating &lt; next_rating:\n                    return False\n        except Exception as e:\n            # If the poll is not found, the vote is not consistent\n            return False\n    return True\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_session/","title":"Check Consistency Session","text":"<p>Class used to elaborate vote consistency in the session.</p>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_session/#apps.votes_results.classes.vote_consistency.check_consistency_session.CheckConsistencySession","title":"<code>CheckConsistencySession</code>","text":"Source code in <code>apps/votes_results/classes/vote_consistency/check_consistency_session.py</code> <pre><code>class CheckConsistencySession:\n    def __init__(self, request: HttpRequest) -&gt; None:\n        self._request: HttpRequest = request\n\n\n\n    def check_consistency(self, poll: PollModel, \n                                mj_ratings: List[dict], \n                                session_single_option_vote_id: str, \n                                session_consistency_check: str) -&gt; bool:\n\"\"\"Checks if the single option vote is consistent with the mj choises. If the vote is not consistent returns \n        True, otherwise False. In case of vote is not consiste, it updates the session parameter in order to notify \n        the user about the inconsistency.\n\n        Returns:\n            bool: True if the vote is not consisnte, False otherwise.\n        \"\"\"\n\n        if (self._checks_for_single_option(poll, session_single_option_vote_id, session_consistency_check, mj_ratings) or \\\n            self._checks_for_schulze(poll, session_single_option_vote_id, session_consistency_check, mj_ratings)):\n\n                # Options selected by the user in order to perform the unconsistent vote if the user wants to perform it.\n                self._request.session[session_consistency_check] = {\n                                                                    'check': True,\n                                                                    'options_selected': self._get_mj_options_selected(self._request.POST.items())\n                                                                    }\n\n                return True # Vote non consistent\n        else:\n            return False\n\n    def clear_session(self, consistency_session_params: List[str]) -&gt; None:\n\"\"\"Clears the consistency session parameters. In safe mode.\n        Args:\n            consistency_session_params (List[str]): The consistency session parameters.\n        \"\"\"\n\n        for param in consistency_session_params:\n            if self._request.session.get(param) is not None:\n                del self._request.session[param]\n\n\n    def _get_mj_options_selected(self, options_selected_from_request: List ) -&gt; dict:\n        options_selected: dict = {\n                                            'id': []\n                                        }\n\n        for key, value in options_selected_from_request:\n                    if not key == 'csrfmiddlewaretoken':\n                        options_selected['id'].append(int(key))\n                        options_selected[int(key)] =  int(value)\n\n        return options_selected\n\n\n    def _checks_for_single_option(self, poll, vote_id, session_consistency_check, mj_ratings) -&gt; bool:\n        return  poll.poll_type == PollModel.PollType.SINGLE_OPTION and \\\n                self._request.session.get(vote_id) and \\\n                self._request.session.get(session_consistency_check) is None and \\\n                not CheckConsistencyMjVote.check(self._request.session.get(vote_id), mj_ratings)\n\n    def _checks_for_schulze(self, poll, vote_id, session_consistency_check, mj_ratings) -&gt; bool:\n        return  poll.poll_type == PollModel.PollType.SCHULZE and \\\n                self._request.session.get(vote_id) and \\\n                self._request.session.get(session_consistency_check) is None and \\\n                not CheckConsistencyShulze.check(self._request.session.get(vote_id), mj_ratings)\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_session/#apps.votes_results.classes.vote_consistency.check_consistency_session.CheckConsistencySession.check_consistency","title":"<code>check_consistency(poll, mj_ratings, session_single_option_vote_id, session_consistency_check)</code>","text":"<p>Checks if the single option vote is consistent with the mj choises. If the vote is not consistent returns  True, otherwise False. In case of vote is not consiste, it updates the session parameter in order to notify  the user about the inconsistency.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the vote is not consisnte, False otherwise.</p> Source code in <code>apps/votes_results/classes/vote_consistency/check_consistency_session.py</code> <pre><code>def check_consistency(self, poll: PollModel, \n                            mj_ratings: List[dict], \n                            session_single_option_vote_id: str, \n                            session_consistency_check: str) -&gt; bool:\n\"\"\"Checks if the single option vote is consistent with the mj choises. If the vote is not consistent returns \n    True, otherwise False. In case of vote is not consiste, it updates the session parameter in order to notify \n    the user about the inconsistency.\n\n    Returns:\n        bool: True if the vote is not consisnte, False otherwise.\n    \"\"\"\n\n    if (self._checks_for_single_option(poll, session_single_option_vote_id, session_consistency_check, mj_ratings) or \\\n        self._checks_for_schulze(poll, session_single_option_vote_id, session_consistency_check, mj_ratings)):\n\n            # Options selected by the user in order to perform the unconsistent vote if the user wants to perform it.\n            self._request.session[session_consistency_check] = {\n                                                                'check': True,\n                                                                'options_selected': self._get_mj_options_selected(self._request.POST.items())\n                                                                }\n\n            return True # Vote non consistent\n    else:\n        return False\n</code></pre>"},{"location":"code_documentation/votes_results/classes/vote_consistency/check_consistency_session/#apps.votes_results.classes.vote_consistency.check_consistency_session.CheckConsistencySession.clear_session","title":"<code>clear_session(consistency_session_params)</code>","text":"<p>Clears the consistency session parameters. In safe mode.</p> <p>Parameters:</p> Name Type Description Default <code>consistency_session_params</code> <code>List[str]</code> <p>The consistency session parameters.</p> required Source code in <code>apps/votes_results/classes/vote_consistency/check_consistency_session.py</code> <pre><code>def clear_session(self, consistency_session_params: List[str]) -&gt; None:\n\"\"\"Clears the consistency session parameters. In safe mode.\n    Args:\n        consistency_session_params (List[str]): The consistency session parameters.\n    \"\"\"\n\n    for param in consistency_session_params:\n        if self._request.session.get(param) is not None:\n            del self._request.session[param]\n</code></pre>"},{"location":"code_documentation/votes_results/services/majority_judgment_vote_service/","title":"Majority Judgment Services","text":"<p>Majority Judgment services related to vote.</p>"},{"location":"code_documentation/votes_results/services/majority_judgment_vote_service/#apps.votes_results.services.majority_judgment_vote_service.MajorityJudjmentVoteService","title":"<code>MajorityJudjmentVoteService</code>","text":"<p>Class that handles vote procedures for the majority vote case</p> Source code in <code>apps/votes_results/services/majority_judgment_vote_service.py</code> <pre><code>class MajorityJudjmentVoteService:\n\"\"\"Class that handles vote procedures for the majority vote case\"\"\"\n\n    @staticmethod\n    def perform_vote(rating_options: List[dict], poll_id: str) -&gt; MajorityVoteModel:\n\"\"\"\n        Perform a vote on a majority vote poll\n        Args:\n            poll_id: the id of the poll.\n            rating_options: List of dictionaries of ratings assigned to an option [{'poll_choice_id': ..., 'rating': ...}, ...].\n        Raises:\n            PollDoesNotExistException: execption raised when the poll selected is not present in the database\n            PollOptionRatingUnvalidException: exception raised when there are no rating choices in the options (None)\n            MajorityNumberOfRatingsNotValid: exception raised when the rating number is not between 1 and 5\n        Returns:\n            vote: the majority vote model created.\n        \"\"\"\n\n        # check if poll exists\n        try:\n            poll: PollModel = PollModel.objects.get(id=poll_id)\n            # todo: add here \"is open\" filter\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Error: Poll with id={poll_id} does not exist\")\n\n        # check if every option has a value assigned\n\n        num_poll_options: int = PollOptionModel.objects.filter(poll_fk=poll_id).count()\n        if num_poll_options != len(rating_options):\n            raise PollOptionRatingUnvalidException(f\"Error: the poll option doesn't have a rating assigned\")\n\n        # check if rating assigned is a number from 1 to 5\n        for num_ratings in rating_options:\n            rating_value = num_ratings.get('rating')\n            if rating_value &lt; 1 or rating_value &gt; 5:\n                raise MajorityNumberOfRatingsNotValid(f\"Error: the poll option has an invalid rating assigned\")\n\n        # todo: add a check if user alredy voted this\n\n        # create majority vote object\n        vote: MajorityVoteModel = MajorityVoteModel()\n        vote.poll = poll\n        vote.save()\n\n        for num_ratings in rating_options:\n            rating_key = num_ratings.get('poll_choice_id')\n            rating_value = num_ratings.get('rating')\n\n            temp_majority_option: MajorityJudgmentModel = MajorityJudgmentModel()\n            temp_majority_option.poll_option = PollOptionModel.objects.filter(poll_fk=poll_id).get(id=rating_key)\n            temp_majority_option.rating = rating_value\n            temp_majority_option.majority_poll_vote = vote\n            temp_majority_option.save()\n\n        return vote\n\n    @staticmethod\n    def calculate_result(poll_id: str, user = None) -&gt; IMajorityJudgmentResults:\n\"\"\"Calculate result of a majority poll.\n\n        Args:\n            poll_id: The id of the poll.\n\n        Raises:\n            PollDoesNotExistException: If the poll does not exist.\n            ResultsNotAvailableException: you tried to access results on a poll that are not available        \n        Returns: \n            List[MajorityPollResultData]: List of calculated result for each option.\n        \"\"\"\n\n        try:\n            poll: PollModel = PollModel.objects.get(id=poll_id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Poll with id={poll_id} does not exist\")\n\n        # check if the results can be viewed\n        if not poll.are_results_visible(user):\n            raise ResultsNotAvailableException(f\"Results of poll with id={poll_id} are not available\")\n\n        # results = NoParityMJResults(poll)\n        results = ParityMJResults(poll)\n        results.calculate()\n\n        return results\n\n    @staticmethod\n    def get_vote_by_id(vote_id: str) -&gt; MajorityVoteModel:\n\"\"\"\n        Retrieve a vote by its ID \n        (temporary method! In future we will wanna use &lt;poll_id, user_id&gt;)\n        Args:\n            vote_id: id of the vote object you want to retrieve\n        Raises:\n            VoteDoesNotExistException: if vote does not exists\n        Returns:\n            MajorityVoteModel: the majority vote model with the specified id\n        \"\"\"\n\n        try:\n            return MajorityVoteModel.objects.get(id=vote_id)\n        except ObjectDoesNotExist:\n            raise VoteDoesNotExistException()\n</code></pre>"},{"location":"code_documentation/votes_results/services/majority_judgment_vote_service/#apps.votes_results.services.majority_judgment_vote_service.MajorityJudjmentVoteService.calculate_result","title":"<code>calculate_result(poll_id, user=None)</code>  <code>staticmethod</code>","text":"<p>Calculate result of a majority poll.</p> <p>Parameters:</p> Name Type Description Default <code>poll_id</code> <code>str</code> <p>The id of the poll.</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>If the poll does not exist.</p> <code>ResultsNotAvailableException</code> <p>you tried to access results on a poll that are not available        </p> <p>Returns:</p> Type Description <code>IMajorityJudgmentResults</code> <p>List[MajorityPollResultData]: List of calculated result for each option.</p> Source code in <code>apps/votes_results/services/majority_judgment_vote_service.py</code> <pre><code>@staticmethod\ndef calculate_result(poll_id: str, user = None) -&gt; IMajorityJudgmentResults:\n\"\"\"Calculate result of a majority poll.\n\n    Args:\n        poll_id: The id of the poll.\n\n    Raises:\n        PollDoesNotExistException: If the poll does not exist.\n        ResultsNotAvailableException: you tried to access results on a poll that are not available        \n    Returns: \n        List[MajorityPollResultData]: List of calculated result for each option.\n    \"\"\"\n\n    try:\n        poll: PollModel = PollModel.objects.get(id=poll_id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Poll with id={poll_id} does not exist\")\n\n    # check if the results can be viewed\n    if not poll.are_results_visible(user):\n        raise ResultsNotAvailableException(f\"Results of poll with id={poll_id} are not available\")\n\n    # results = NoParityMJResults(poll)\n    results = ParityMJResults(poll)\n    results.calculate()\n\n    return results\n</code></pre>"},{"location":"code_documentation/votes_results/services/majority_judgment_vote_service/#apps.votes_results.services.majority_judgment_vote_service.MajorityJudjmentVoteService.get_vote_by_id","title":"<code>get_vote_by_id(vote_id)</code>  <code>staticmethod</code>","text":"<p>Retrieve a vote by its ID  (temporary method! In future we will wanna use ) <p>Parameters:</p> Name Type Description Default <code>vote_id</code> <code>str</code> <p>id of the vote object you want to retrieve</p> required <p>Raises:</p> Type Description <code>VoteDoesNotExistException</code> <p>if vote does not exists</p> <p>Returns:</p> Name Type Description <code>MajorityVoteModel</code> <code>MajorityVoteModel</code> <p>the majority vote model with the specified id</p> Source code in <code>apps/votes_results/services/majority_judgment_vote_service.py</code> <pre><code>@staticmethod\ndef get_vote_by_id(vote_id: str) -&gt; MajorityVoteModel:\n\"\"\"\n    Retrieve a vote by its ID \n    (temporary method! In future we will wanna use &lt;poll_id, user_id&gt;)\n    Args:\n        vote_id: id of the vote object you want to retrieve\n    Raises:\n        VoteDoesNotExistException: if vote does not exists\n    Returns:\n        MajorityVoteModel: the majority vote model with the specified id\n    \"\"\"\n\n    try:\n        return MajorityVoteModel.objects.get(id=vote_id)\n    except ObjectDoesNotExist:\n        raise VoteDoesNotExistException()\n</code></pre>"},{"location":"code_documentation/votes_results/services/majority_judgment_vote_service/#apps.votes_results.services.majority_judgment_vote_service.MajorityJudjmentVoteService.perform_vote","title":"<code>perform_vote(rating_options, poll_id)</code>  <code>staticmethod</code>","text":"<p>Perform a vote on a majority vote poll</p> <p>Parameters:</p> Name Type Description Default <code>poll_id</code> <code>str</code> <p>the id of the poll.</p> required <code>rating_options</code> <code>List[dict]</code> <p>List of dictionaries of ratings assigned to an option [{'poll_choice_id': ..., 'rating': ...}, ...].</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>execption raised when the poll selected is not present in the database</p> <code>PollOptionRatingUnvalidException</code> <p>exception raised when there are no rating choices in the options (None)</p> <code>MajorityNumberOfRatingsNotValid</code> <p>exception raised when the rating number is not between 1 and 5</p> <p>Returns:</p> Name Type Description <code>vote</code> <code>MajorityVoteModel</code> <p>the majority vote model created.</p> Source code in <code>apps/votes_results/services/majority_judgment_vote_service.py</code> <pre><code>@staticmethod\ndef perform_vote(rating_options: List[dict], poll_id: str) -&gt; MajorityVoteModel:\n\"\"\"\n    Perform a vote on a majority vote poll\n    Args:\n        poll_id: the id of the poll.\n        rating_options: List of dictionaries of ratings assigned to an option [{'poll_choice_id': ..., 'rating': ...}, ...].\n    Raises:\n        PollDoesNotExistException: execption raised when the poll selected is not present in the database\n        PollOptionRatingUnvalidException: exception raised when there are no rating choices in the options (None)\n        MajorityNumberOfRatingsNotValid: exception raised when the rating number is not between 1 and 5\n    Returns:\n        vote: the majority vote model created.\n    \"\"\"\n\n    # check if poll exists\n    try:\n        poll: PollModel = PollModel.objects.get(id=poll_id)\n        # todo: add here \"is open\" filter\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Error: Poll with id={poll_id} does not exist\")\n\n    # check if every option has a value assigned\n\n    num_poll_options: int = PollOptionModel.objects.filter(poll_fk=poll_id).count()\n    if num_poll_options != len(rating_options):\n        raise PollOptionRatingUnvalidException(f\"Error: the poll option doesn't have a rating assigned\")\n\n    # check if rating assigned is a number from 1 to 5\n    for num_ratings in rating_options:\n        rating_value = num_ratings.get('rating')\n        if rating_value &lt; 1 or rating_value &gt; 5:\n            raise MajorityNumberOfRatingsNotValid(f\"Error: the poll option has an invalid rating assigned\")\n\n    # todo: add a check if user alredy voted this\n\n    # create majority vote object\n    vote: MajorityVoteModel = MajorityVoteModel()\n    vote.poll = poll\n    vote.save()\n\n    for num_ratings in rating_options:\n        rating_key = num_ratings.get('poll_choice_id')\n        rating_value = num_ratings.get('rating')\n\n        temp_majority_option: MajorityJudgmentModel = MajorityJudgmentModel()\n        temp_majority_option.poll_option = PollOptionModel.objects.filter(poll_fk=poll_id).get(id=rating_key)\n        temp_majority_option.rating = rating_value\n        temp_majority_option.majority_poll_vote = vote\n        temp_majority_option.save()\n\n    return vote\n</code></pre>"},{"location":"code_documentation/votes_results/services/schulze_method_vote_service/","title":"Schulze Method Services","text":"<p>Schulze Method services related to vote.</p>"},{"location":"code_documentation/votes_results/services/schulze_method_vote_service/#apps.votes_results.services.schulze_method_vote_service.SchulzeMethodVoteService","title":"<code>SchulzeMethodVoteService</code>","text":"<p>Class that handles vote procedures for the majority vote case</p> Source code in <code>apps/votes_results/services/schulze_method_vote_service.py</code> <pre><code>class SchulzeMethodVoteService:\n\"\"\"Class that handles vote procedures for the majority vote case\"\"\"\n\n    @staticmethod\n    def perform_vote(options_rated: List[str], poll_id: str) -&gt; SchulzeVoteModel:\n\"\"\"\n        Perform a vote on a majority vote poll\n        Args:\n            poll_id: the id of the poll.\n            options_rated: List of string of option id [12,14,13,15] \n        Raises:\n            PollDoesNotExistException: execption raised when the poll selected is not present in the database\n        Returns:\n            vote: the schulze vote model created.\n        \"\"\"\n\n        # check if poll exists\n        try:\n            poll: PollModel = PollModel.objects.get(id=poll_id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Error: Poll with id={poll_id} does not exist\")\n\n\n        # create schulze vote object\n        vote: SchulzeVoteModel = SchulzeVoteModel()\n        vote.poll = poll\n        user_order :List = []\n        for opt in options_rated:\n            user_order.append(int(opt))\n        vote.set_order(user_order)\n        vote.save()\n\n        return vote\n\n    @staticmethod\n    def calculate_result(poll: PollModel, user = None) -&gt; SchulzeResultsAdapter:\n\"\"\"\n        Calculate result of a poll.\n        Args:\n            poll: the poll you want to calculate results\n        Raises:\n            PollDoesNotExistException: you tried to calculate results on a non-existent poll\n            ResultsNotAvailableException: raised if you try to check results not visible\n        Returns:\n            result: list of PollOptions sorted by ranking number as Schulze algorithm results\n        \"\"\"\n\n        try:\n            poll: PollModel = PollModel.objects.get(id=poll.id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Poll with id={poll.id} does not exist\")\n\n        # check if the results can be viewed\n        if not poll.are_results_visible(user):\n            raise ResultsNotAvailableException(f\"Results of poll with id={poll.id} are not available\")\n\n        result: SchulzeResultsAdapter = SchulzeResultsAdapter(poll)\n        result.calculate()\n\n        return result\n\n    @staticmethod\n    def get_vote_by_id(vote_id: str) -&gt; SchulzeVoteModel:\n\"\"\"\n        Retrieve a vote by its ID \n        (temporary method! In future we will wanna use &lt;poll_id, user_id&gt;)\n        Args:\n            vote_id: id of the vote object you want to retrieve\n        Raises:\n            VoteDoesNotExistException: if vote does not exists\n        Returns:\n            SchulzeVoteModel: schulze vote by the specified id\n        \"\"\"\n\n        try:\n            return SchulzeVoteModel.objects.get(id=vote_id)\n        except ObjectDoesNotExist:\n            raise VoteDoesNotExistException()\n</code></pre>"},{"location":"code_documentation/votes_results/services/schulze_method_vote_service/#apps.votes_results.services.schulze_method_vote_service.SchulzeMethodVoteService.calculate_result","title":"<code>calculate_result(poll, user=None)</code>  <code>staticmethod</code>","text":"<p>Calculate result of a poll.</p> <p>Parameters:</p> Name Type Description Default <code>poll</code> <code>PollModel</code> <p>the poll you want to calculate results</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>you tried to calculate results on a non-existent poll</p> <code>ResultsNotAvailableException</code> <p>raised if you try to check results not visible</p> <p>Returns:</p> Name Type Description <code>result</code> <code>SchulzeResultsAdapter</code> <p>list of PollOptions sorted by ranking number as Schulze algorithm results</p> Source code in <code>apps/votes_results/services/schulze_method_vote_service.py</code> <pre><code>@staticmethod\ndef calculate_result(poll: PollModel, user = None) -&gt; SchulzeResultsAdapter:\n\"\"\"\n    Calculate result of a poll.\n    Args:\n        poll: the poll you want to calculate results\n    Raises:\n        PollDoesNotExistException: you tried to calculate results on a non-existent poll\n        ResultsNotAvailableException: raised if you try to check results not visible\n    Returns:\n        result: list of PollOptions sorted by ranking number as Schulze algorithm results\n    \"\"\"\n\n    try:\n        poll: PollModel = PollModel.objects.get(id=poll.id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Poll with id={poll.id} does not exist\")\n\n    # check if the results can be viewed\n    if not poll.are_results_visible(user):\n        raise ResultsNotAvailableException(f\"Results of poll with id={poll.id} are not available\")\n\n    result: SchulzeResultsAdapter = SchulzeResultsAdapter(poll)\n    result.calculate()\n\n    return result\n</code></pre>"},{"location":"code_documentation/votes_results/services/schulze_method_vote_service/#apps.votes_results.services.schulze_method_vote_service.SchulzeMethodVoteService.get_vote_by_id","title":"<code>get_vote_by_id(vote_id)</code>  <code>staticmethod</code>","text":"<p>Retrieve a vote by its ID  (temporary method! In future we will wanna use ) <p>Parameters:</p> Name Type Description Default <code>vote_id</code> <code>str</code> <p>id of the vote object you want to retrieve</p> required <p>Raises:</p> Type Description <code>VoteDoesNotExistException</code> <p>if vote does not exists</p> <p>Returns:</p> Name Type Description <code>SchulzeVoteModel</code> <code>SchulzeVoteModel</code> <p>schulze vote by the specified id</p> Source code in <code>apps/votes_results/services/schulze_method_vote_service.py</code> <pre><code>@staticmethod\ndef get_vote_by_id(vote_id: str) -&gt; SchulzeVoteModel:\n\"\"\"\n    Retrieve a vote by its ID \n    (temporary method! In future we will wanna use &lt;poll_id, user_id&gt;)\n    Args:\n        vote_id: id of the vote object you want to retrieve\n    Raises:\n        VoteDoesNotExistException: if vote does not exists\n    Returns:\n        SchulzeVoteModel: schulze vote by the specified id\n    \"\"\"\n\n    try:\n        return SchulzeVoteModel.objects.get(id=vote_id)\n    except ObjectDoesNotExist:\n        raise VoteDoesNotExistException()\n</code></pre>"},{"location":"code_documentation/votes_results/services/schulze_method_vote_service/#apps.votes_results.services.schulze_method_vote_service.SchulzeMethodVoteService.perform_vote","title":"<code>perform_vote(options_rated, poll_id)</code>  <code>staticmethod</code>","text":"<p>Perform a vote on a majority vote poll</p> <p>Parameters:</p> Name Type Description Default <code>poll_id</code> <code>str</code> <p>the id of the poll.</p> required <code>options_rated</code> <code>List[str]</code> <p>List of string of option id [12,14,13,15] </p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>execption raised when the poll selected is not present in the database</p> <p>Returns:</p> Name Type Description <code>vote</code> <code>SchulzeVoteModel</code> <p>the schulze vote model created.</p> Source code in <code>apps/votes_results/services/schulze_method_vote_service.py</code> <pre><code>@staticmethod\ndef perform_vote(options_rated: List[str], poll_id: str) -&gt; SchulzeVoteModel:\n\"\"\"\n    Perform a vote on a majority vote poll\n    Args:\n        poll_id: the id of the poll.\n        options_rated: List of string of option id [12,14,13,15] \n    Raises:\n        PollDoesNotExistException: execption raised when the poll selected is not present in the database\n    Returns:\n        vote: the schulze vote model created.\n    \"\"\"\n\n    # check if poll exists\n    try:\n        poll: PollModel = PollModel.objects.get(id=poll_id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Error: Poll with id={poll_id} does not exist\")\n\n\n    # create schulze vote object\n    vote: SchulzeVoteModel = SchulzeVoteModel()\n    vote.poll = poll\n    user_order :List = []\n    for opt in options_rated:\n        user_order.append(int(opt))\n    vote.set_order(user_order)\n    vote.save()\n\n    return vote\n</code></pre>"},{"location":"code_documentation/votes_results/services/single_option_vote_service/","title":"Single Option Services","text":"<p>Single Option services related to vote.</p>"},{"location":"code_documentation/votes_results/services/single_option_vote_service/#apps.votes_results.services.single_option_vote_service.SingleOptionVoteService","title":"<code>SingleOptionVoteService</code>","text":"<p>Handle vote procedures like:</p> <ul> <li>perform a vote on a simple poll (one choice)</li> <li>calculate results on a simple poll</li> </ul> Source code in <code>apps/votes_results/services/single_option_vote_service.py</code> <pre><code>class SingleOptionVoteService: \n\"\"\"\n    Handle vote procedures like:\n\n    - perform a vote on a simple poll (one choice)\n    - calculate results on a simple poll\n    \"\"\"\n\n    @staticmethod\n    def perform_vote(poll_id: str, poll_choice_id: str) -&gt; VoteModel:\n\"\"\"\n        Perform a vote on a survey.\n        Args:\n            poll_id: id of poll you want to vote\n            poll_choice_id: the voted option\n        Raises: \n            PollDoesNotExistException: you tried to vote a not existent poll\n            PollOptionUnvalidException: you tried to vote an unvalid option \n                (id doesn't exists or it doesn't belong to this poll)\n        Returns:\n            vote: the vote model of the result\n        \"\"\"\n\n        vote_builder = VoteBuilder()\n\n        vote_builder.set_poll(poll_id)\n        vote_builder.set_voted_option(poll_choice_id)\n\n        vote: VoteModel = vote_builder.perform_creation()\n        vote.save()\n\n        return vote\n\n    @staticmethod\n    def get_vote_by_id(vote_id: str) -&gt; VoteModel:\n\"\"\"\n        Retrieve a vote by its ID \n        (temporary method! In future we will wanna use &lt;poll_id, user_id&gt;)\n        Args:\n            vote_id: id of the vote object you want to retrieve\n        Raises:\n            VoteDoesNotExistException: if vote does not exists\n        Returns:\n            VoteModel: the vote object by the specified id\n        \"\"\"\n\n        try:\n            return VoteModel.objects.get(id=vote_id)\n        except ObjectDoesNotExist:\n            raise VoteDoesNotExistException()\n\n    @staticmethod\n    def calculate_result(poll_id: str, user = None) -&gt; PollResult:\n\"\"\"\n        Calculate result of a poll.\n        Args:\n            poll_id: id of poll you want to calculate results\n        Raises:\n            PollDoesNotExistException: you tried to calculate results on a non-existent poll\n            ResultsNotAvailableException: you tried to access results on a poll that are not available\n        Returns:\n            PollResult: results of the poll specified by id\n        \"\"\"\n\n        try:\n            poll: PollModel = PollModel.objects.get(id=poll_id)\n        except ObjectDoesNotExist:\n            raise PollDoesNotExistException(f\"Poll with id={poll_id} does not exist\")\n\n        # check if the results can be viewed\n        if not poll.are_results_visible(user):\n            raise ResultsNotAvailableException(f\"Results of poll with id={poll_id} are not available\")\n\n\n\n        return PollResult(poll)\n</code></pre>"},{"location":"code_documentation/votes_results/services/single_option_vote_service/#apps.votes_results.services.single_option_vote_service.SingleOptionVoteService.calculate_result","title":"<code>calculate_result(poll_id, user=None)</code>  <code>staticmethod</code>","text":"<p>Calculate result of a poll.</p> <p>Parameters:</p> Name Type Description Default <code>poll_id</code> <code>str</code> <p>id of poll you want to calculate results</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>you tried to calculate results on a non-existent poll</p> <code>ResultsNotAvailableException</code> <p>you tried to access results on a poll that are not available</p> <p>Returns:</p> Name Type Description <code>PollResult</code> <code>PollResult</code> <p>results of the poll specified by id</p> Source code in <code>apps/votes_results/services/single_option_vote_service.py</code> <pre><code>@staticmethod\ndef calculate_result(poll_id: str, user = None) -&gt; PollResult:\n\"\"\"\n    Calculate result of a poll.\n    Args:\n        poll_id: id of poll you want to calculate results\n    Raises:\n        PollDoesNotExistException: you tried to calculate results on a non-existent poll\n        ResultsNotAvailableException: you tried to access results on a poll that are not available\n    Returns:\n        PollResult: results of the poll specified by id\n    \"\"\"\n\n    try:\n        poll: PollModel = PollModel.objects.get(id=poll_id)\n    except ObjectDoesNotExist:\n        raise PollDoesNotExistException(f\"Poll with id={poll_id} does not exist\")\n\n    # check if the results can be viewed\n    if not poll.are_results_visible(user):\n        raise ResultsNotAvailableException(f\"Results of poll with id={poll_id} are not available\")\n\n\n\n    return PollResult(poll)\n</code></pre>"},{"location":"code_documentation/votes_results/services/single_option_vote_service/#apps.votes_results.services.single_option_vote_service.SingleOptionVoteService.get_vote_by_id","title":"<code>get_vote_by_id(vote_id)</code>  <code>staticmethod</code>","text":"<p>Retrieve a vote by its ID  (temporary method! In future we will wanna use ) <p>Parameters:</p> Name Type Description Default <code>vote_id</code> <code>str</code> <p>id of the vote object you want to retrieve</p> required <p>Raises:</p> Type Description <code>VoteDoesNotExistException</code> <p>if vote does not exists</p> <p>Returns:</p> Name Type Description <code>VoteModel</code> <code>VoteModel</code> <p>the vote object by the specified id</p> Source code in <code>apps/votes_results/services/single_option_vote_service.py</code> <pre><code>@staticmethod\ndef get_vote_by_id(vote_id: str) -&gt; VoteModel:\n\"\"\"\n    Retrieve a vote by its ID \n    (temporary method! In future we will wanna use &lt;poll_id, user_id&gt;)\n    Args:\n        vote_id: id of the vote object you want to retrieve\n    Raises:\n        VoteDoesNotExistException: if vote does not exists\n    Returns:\n        VoteModel: the vote object by the specified id\n    \"\"\"\n\n    try:\n        return VoteModel.objects.get(id=vote_id)\n    except ObjectDoesNotExist:\n        raise VoteDoesNotExistException()\n</code></pre>"},{"location":"code_documentation/votes_results/services/single_option_vote_service/#apps.votes_results.services.single_option_vote_service.SingleOptionVoteService.perform_vote","title":"<code>perform_vote(poll_id, poll_choice_id)</code>  <code>staticmethod</code>","text":"<p>Perform a vote on a survey.</p> <p>Parameters:</p> Name Type Description Default <code>poll_id</code> <code>str</code> <p>id of poll you want to vote</p> required <code>poll_choice_id</code> <code>str</code> <p>the voted option</p> required <p>Raises:</p> Type Description <code>PollDoesNotExistException</code> <p>you tried to vote a not existent poll</p> <code>PollOptionUnvalidException</code> <p>you tried to vote an unvalid option  (id doesn't exists or it doesn't belong to this poll)</p> <p>Returns:</p> Name Type Description <code>vote</code> <code>VoteModel</code> <p>the vote model of the result</p> Source code in <code>apps/votes_results/services/single_option_vote_service.py</code> <pre><code>@staticmethod\ndef perform_vote(poll_id: str, poll_choice_id: str) -&gt; VoteModel:\n\"\"\"\n    Perform a vote on a survey.\n    Args:\n        poll_id: id of poll you want to vote\n        poll_choice_id: the voted option\n    Raises: \n        PollDoesNotExistException: you tried to vote a not existent poll\n        PollOptionUnvalidException: you tried to vote an unvalid option \n            (id doesn't exists or it doesn't belong to this poll)\n    Returns:\n        vote: the vote model of the result\n    \"\"\"\n\n    vote_builder = VoteBuilder()\n\n    vote_builder.set_poll(poll_id)\n    vote_builder.set_voted_option(poll_choice_id)\n\n    vote: VoteModel = vote_builder.perform_creation()\n    vote.save()\n\n    return vote\n</code></pre>"}]}